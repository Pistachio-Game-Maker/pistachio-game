<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pistachio - Online Multiplayer Card Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect } = React;

    const firebaseConfig = {
      apiKey: "AIzaSyAP5BJbHJXE2qlxF7xZ3LZU7wUHMiae4Q0",
      authDomain: "pistachio-80ed1.firebaseapp.com",
      databaseURL: "https://pistachio-80ed1-default-rtdb.firebaseio.com",
      projectId: "pistachio-80ed1",
      storageBucket: "pistachio-80ed1.firebasestorage.app",
      messagingSenderId: "1065517356603",
      appId: "1:1065517356603:web:22f17f20546ce44e7fae1e"
    };

    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const database = firebase.database();

    const CARD_IMAGES = {
      pistachio: 'images/cards/pistachio.PNG',
      pesky: 'images/cards/pesky.PNG',
      shell: 'images/cards/shell.PNG',
      loose: 'images/cards/loose.PNG',
      golden: 'images/cards/golden.PNG',
      raisin: 'images/cards/raisin.PNG',
      moldy: 'images/cards/moldy.PNG',
      goldenShell: 'images/cards/goldenShell.PNG',
      nutcracker: 'images/cards/nutcracker.PNG',
      gorilla: 'images/cards/gorilla.PNG',
      slap: 'images/cards/slap.PNG',
      picky: 'images/cards/picky.PNG',
      raccoon: 'images/cards/raccoon.PNG',
      spillBowl: 'images/cards/spillBowl.PNG',
      fast: 'images/cards/fast.PNG',
      caffeinated: 'images/cards/caffeinated.PNG',
      donate: 'images/cards/donate.PNG',
      cardBack: 'images/cards/cardBack.PNG'
    };

    const CARD_DECK = [
      { type: 'pistachio', count: 13, category: 'edible' },
      { type: 'pesky', count: 8, category: 'edible' },
      { type: 'shell', count: 12, category: 'shell' },
      { type: 'loose', count: 4, category: 'edible' },
      { type: 'golden', count: 3, category: 'edible' },
      { type: 'raisin', count: 1, category: 'edible' },
      { type: 'moldy', count: 5, category: 'moldy' },
      { type: 'spillBowl', count: 2, category: 'special' },
      { type: 'fast', count: 5, category: 'special' },
      { type: 'raccoon', count: 5, category: 'special' },
      { type: 'picky', count: 4, category: 'special' },
      { type: 'slap', count: 8, category: 'special' },
      { type: 'caffeinated', count: 6, category: 'special' },
      { type: 'donate', count: 5, category: 'special' },
      { type: 'nutcracker', count: 0, category: 'tool' },
      { type: 'gorilla', count: 0, category: 'tool' }
    ];

    const PLAYER_COLORS = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b'];

    const createDeck = (playerCount) => {
      const deck = [];
      CARD_DECK.forEach(card => {
        let count = card.count;
        if (card.type === 'nutcracker' || card.type === 'gorilla') {
          count = playerCount;
        }
        for (let i = 0; i < count; i++) {
          deck.push({ ...card, id: `${card.type}-${Math.random().toString(36).substr(2, 9)}` });
        }
      });
      return shuffleDeck(deck);
    };

    const shuffleDeck = (deck) => {
      const shuffled = [...deck];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    };

    const generateRoomCode = () => {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    };

    function PistachioGame() {
      const [screen, setScreen] = useState('menu');
      const [roomCode, setRoomCode] = useState('');
      const [joinCode, setJoinCode] = useState('');
      const [playerName, setPlayerName] = useState('');
      const [playerId, setPlayerId] = useState('');
      const [gameState, setGameState] = useState(null);
      const [copied, setCopied] = useState(false);
      const [error, setError] = useState('');
      const [selectedCaffeineIndex, setSelectedCaffeineIndex] = useState(null);
      const [shellBowlMode, setShellBowlMode] = useState(false);
      const [selectedShellIndices, setSelectedShellIndices] = useState([]);
      const [pickyReorderedCards, setPickyReorderedCards] = useState([]);
      const [pickySelectedIndices, setPickySelectedIndices] = useState([]);
      const [selectedEdibleIndices, setSelectedEdibleIndices] = useState([]);
      const [multiEatMode, setMultiEatMode] = useState(false);
      const [zoomedCard, setZoomedCard] = useState(null);
      const [showRules, setShowRules] = useState(false);

      useEffect(() => {
        if (!playerId) {
          setPlayerId(`player-${Date.now()}-${Math.random().toString(36).substring(7)}`);
        }
      }, [playerId]);

      useEffect(() => {
        if (!roomCode) return;

        const gameRef = database.ref(`games/${roomCode}`);
        const listener = gameRef.on('value', (snapshot) => {
          const data = snapshot.val();
          if (data) {
            setGameState(data);
            if (data.status === 'playing' && screen !== 'game') {
              setScreen('game');
            }
            
            if (data.pendingAction?.type === 'picky' && data.pendingAction.playerId === playerId && pickyReorderedCards.length === 0) {
              setPickyReorderedCards(data.pendingAction.topCards);
              setPickySelectedIndices([]);
            }
          }
        });

        return () => gameRef.off('value', listener);
      }, [roomCode, screen, playerId, pickyReorderedCards.length]);

      const createGame = async () => {
        if (!playerName.trim()) {
          setError('Please enter your name');
          return;
        }
        
        const code = generateRoomCode();
        const newGame = {
          roomCode: code,
          players: {},
          host: playerId,
          status: 'lobby',
          deck: [],
          goldenDeck: [],
          discardPile: [],
          shellBowl: [],
          tokenBowl: 0,
          hungerMarker: false,
          currentPlayerIndex: 0,
          turnPhase: 'draw',
          createdAt: Date.now()
        };

        newGame.players[playerId] = {
          id: playerId,
          name: playerName,
          hand: [],
          energyTokens: 10,
          colorIndex: 0,
          goldenShells: [],
          tools: [],
          connected: true
        };

        try {
          await database.ref(`games/${code}`).set(newGame);
          setRoomCode(code);
          setScreen('lobby');
          setError('');
        } catch (err) {
          setError('Failed to create game: ' + err.message);
        }
      };

      const joinGame = async () => {
        if (!playerName.trim() || !joinCode.trim()) {
          setError('Please enter your name and room code');
          return;
        }
        
        const code = joinCode.toUpperCase();
        
        try {
          const gameRef = database.ref(`games/${code}`);
          const snapshot = await gameRef.once('value');
          const game = snapshot.val();
          
          if (!game) {
            setError('Game not found');
            return;
          }

          const existingPlayer = Object.values(game.players || {}).find(p => p.name === playerName && !p.connected);
          
          if (existingPlayer) {
            await database.ref(`games/${code}/players/${existingPlayer.id}/connected`).set(true);
            setPlayerId(existingPlayer.id);
            setRoomCode(code);
            setScreen(game.status === 'lobby' ? 'lobby' : 'game');
            setError('');
            return;
          }

          if (game.status !== 'lobby') {
            setError('Game already started');
            return;
          }

          const playerCount = Object.keys(game.players).length;
          if (playerCount >= 4) {
            setError('Game is full');
            return;
          }

          const colorIndex = playerCount;
          const newPlayer = {
            id: playerId,
            name: playerName,
            hand: [],
            energyTokens: 10,
            colorIndex,
            goldenShells: [],
            tools: [],
            connected: true
          };

          await database.ref(`games/${code}/players/${playerId}`).set(newPlayer);
          setRoomCode(code);
          setScreen('lobby');
          setError('');
        } catch (err) {
          setError('Failed to join game: ' + err.message);
        }
      };

      const startGame = async () => {
        if (!gameState) return;
        
        const playerCount = Object.keys(gameState.players).length;
        if (playerCount < 3) {
          setError('Need at least 3 players to start!');
          return;
        }

        const deck = createDeck(playerCount);
        const goldenDeck = [];
        for (let i = 0; i < 9; i++) {
          goldenDeck.push({ type: 'goldenShell', category: 'golden', id: `golden-${i}` });
        }
        const firstPlayerIndex = Math.floor(Math.random() * playerCount);

        try {
          await database.ref(`games/${roomCode}`).update({
            status: 'playing',
            deck,
            goldenDeck: shuffleDeck(goldenDeck),
            currentPlayerIndex: firstPlayerIndex,
            turnPhase: 'draw'
          });
          setError('');
        } catch (err) {
          setError('Failed to start game: ' + err.message);
        }
      };

      const handleOverencumbered = async () => {
        if (!gameState) return;
        
        const myPlayer = gameState.players[playerId];
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        
        if (overCount <= 0) return;
        
        if (myPlayer.energyTokens < overCount) {
          setError(`Need ${overCount} energy tokens but only have ${myPlayer.energyTokens}!`);
          return;
        }
        
        const newTokens = myPlayer.energyTokens - overCount;
        
        const updates = {
          [`players/${playerId}/energyTokens`]: newTokens,
          tokenBowl: (gameState.tokenBowl || 0) + overCount
        };
        
        if (newTokens === 0) {
          const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
          updates[`players/${playerId}/eliminated`] = true;
          
          // Discard tools and golden shells
          const deadPlayerHand = myPlayer.hand || [];
          const deadPlayerTools = myPlayer.tools || [];
          const deadPlayerGoldenShells = myPlayer.goldenShells || [];
          
          const toolsAndShells = [...deadPlayerTools.map(t => ({ type: t, category: 'tool', id: `${t}-discarded` })), 
                                   ...deadPlayerGoldenShells];
          
          // Distribute hand to players counter-clockwise starting from previous player
          const currentIndex = gameState.currentPlayerIndex;
          const previousIndex = (currentIndex - 1 + players.length) % players.length;
          
          let cardIndex = 0;
          for (let i = 0; i < players.length - 1; i++) {
            const playerIndex = (previousIndex - i + players.length) % players.length;
            const targetPlayer = players[playerIndex];
            if (targetPlayer.id !== playerId && cardIndex < deadPlayerHand.length) {
              const cardToGive = deadPlayerHand[cardIndex];
              updates[`players/${targetPlayer.id}/hand`] = [...(targetPlayer.hand || []), cardToGive];
              cardIndex++;
            }
          }
          
          // Rest of hand goes to discard
          const remainingCards = deadPlayerHand.slice(cardIndex);
          updates['discardPile'] = [...(gameState.discardPile || []), ...toolsAndShells, ...remainingCards];
          
          updates['currentPlayerIndex'] = (gameState.currentPlayerIndex + 1) % players.length;
          
          const remainingPlayers = players.filter(p => p.id !== playerId);
          if (remainingPlayers.length === 1) {
            updates['status'] = 'finished';
            updates['winner'] = remainingPlayers[0].id;
            updates['winType'] = 'lastStanding';
          }
        }
        
        await database.ref(`games/${roomCode}`).update(updates);
        setError('');
      };

      const drawCard = async () => {
        if (!gameState) return;
        
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        const currentPlayer = players[gameState.currentPlayerIndex];
        
        if (currentPlayer.id !== playerId) return;
        
        const myPlayer = gameState.players[playerId];
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        
        if (overCount > 0) {
          setError('You must pay the overencumbered penalty first!');
          return;
        }
        
        if (gameState.goldenPistachioEvent && 
            gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
            !gameState.goldenPistachioEvent.responses?.[playerId]) {
          setError('You must respond to the Golden Pistachio event first!');
          return;
        }
        
        if (gameState.hungerMarker) {
          setError('You must handle the Hunger Event first! Eat food or pay 1 energy token.');
          return;
        }
        
        if (!gameState.deck || gameState.deck.length === 0) {
          // Reshuffle discard pile into deck
          if (gameState.discardPile && gameState.discardPile.length > 0) {
            const newDeck = shuffleDeck([...gameState.discardPile]);
            const penaltyUpdates = {
              deck: newDeck,
              discardPile: []
            };
            
            // All players lose 1 energy token
            Object.values(gameState.players).forEach(player => {
              if (player.connected && !player.eliminated) {
                const newEnergy = Math.max(0, player.energyTokens - 1);
                penaltyUpdates[`players/${player.id}/energyTokens`] = newEnergy;
                
                if (newEnergy === 0 && player.id !== playerId) {
                  penaltyUpdates[`players/${player.id}/eliminated`] = true;
                }
              }
            });
            
            await database.ref(`games/${roomCode}`).update(penaltyUpdates);
            
            setError('‚ö†Ô∏è DECK RESHUFFLED! All players lose 1 energy token!');
            
            // If this player is now eliminated, handle it
            if (myPlayer.energyTokens - 1 <= 0) {
              return;
            }
            
            // Continue with draw after reshuffle
          } else {
            setError('Deck and discard pile are both empty!');
            return;
          }
        }

        const cardsToDraw = myPlayer.tools?.includes('gorilla') ? 2 : 1;
        const newDeck = [...gameState.deck];
        
        // If we're about to draw the last card(s), trigger reshuffle after
        const willEmptyDeck = newDeck.length <= cardsToDraw;
        
        const drawnCards = newDeck.splice(0, Math.min(cardsToDraw, newDeck.length));
        
        const moldyCards = drawnCards.filter(card => card.type === 'moldy');
        const nonMoldyCards = drawnCards.filter(card => card.type !== 'moldy');
        
        // Check if player has bonus draws from loose pistachios played this turn
        const bonusDraws = myPlayer.looseBonusDraws || 0;
        let extraCards = [];
        if (bonusDraws > 0 && newDeck.length > 0) {
          extraCards = newDeck.splice(0, Math.min(bonusDraws, newDeck.length));
          nonMoldyCards.push(...extraCards.filter(c => c.type !== 'moldy'));
          moldyCards.push(...extraCards.filter(c => c.type === 'moldy'));
        }
        
        const newHand = [...(myPlayer.hand || []), ...nonMoldyCards];
        
        if (moldyCards.length > 0) {
          const newDiscard = [...(gameState.discardPile || []), ...moldyCards];
          
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            deck: newDeck,
            discardPile: newDiscard,
            [`players/${playerId}/looseBonusDraws`]: 0,
            pendingAction: {
              type: 'moldy',
              playerId: playerId,
              count: moldyCards.length
            }
          });
          
          if (bonusDraws > 0) {
            setError(`Drew ${bonusDraws} extra card(s) from Loose Pistachios!`);
          }
          
          // Trigger reshuffle notification if needed
          if (willEmptyDeck && gameState.discardPile && gameState.discardPile.length > 0) {
            setError('‚ö†Ô∏è Last card drawn! Deck will reshuffle next draw - all players lose 1 energy!');
          }
        } else {
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            deck: newDeck,
            currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
            turnPhase: 'draw',
            [`players/${playerId}/looseBonusDraws`]: 0
            // Don't touch hungerMarker here - it persists across turns
          });
          
          if (bonusDraws > 0) {
            setError(`Drew ${bonusDraws} extra card(s) from Loose Pistachios!`);
          }
          
          // Trigger reshuffle notification if needed
          if (willEmptyDeck && gameState.discardPile && gameState.discardPile.length > 0) {
            setError('‚ö†Ô∏è Last card drawn! Deck will reshuffle next draw - all players lose 1 energy!');
          }
        }
      };

      const eatMultipleFoods = async () => {
        if (!gameState || selectedEdibleIndices.length === 0) return;
        
        const myPlayer = gameState.players[playerId];
        const cardsToEat = selectedEdibleIndices.map(idx => myPlayer.hand[idx]);
        
        const hasPesky = cardsToEat.some(c => c.type === 'pesky');
        if (hasPesky && !myPlayer.tools?.includes('nutcracker')) {
          setError('Cannot eat Pesky Pistachio without a Nutcracker!');
          return;
        }
        
        const newHand = myPlayer.hand.filter((_, idx) => !selectedEdibleIndices.includes(idx));
        const newDiscard = [...(gameState.discardPile || []), ...cardsToEat];
        
        const updates = {
          [`players/${playerId}/hand`]: newHand,
          discardPile: newDiscard
        };
        
        // Count loose pistachios for bonus draws
        const looseCount = cardsToEat.filter(c => c.type === 'loose').length;
        if (looseCount > 0) {
          const currentBonus = myPlayer.looseBonusDraws || 0;
          updates[`players/${playerId}/looseBonusDraws`] = currentBonus + looseCount;
        }
        
        if (cardsToEat.length >= 2) {
          const newTokens = Math.min(10, myPlayer.energyTokens + 1);
          updates[`players/${playerId}/energyTokens`] = newTokens;
        }
        
        if (gameState.pendingAction?.type === 'moldy' && gameState.pendingAction.playerId === playerId) {
          const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
          updates['currentPlayerIndex'] = (gameState.currentPlayerIndex + 1) % players.length;
          updates['pendingAction'] = null;
        }
        else if (gameState.goldenPistachioEvent && 
            gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
            !gameState.goldenPistachioEvent.responses?.[playerId]) {
          updates[`goldenPistachioEvent/responses/${playerId}`] = 'ate';
          
          const responses = {...(gameState.goldenPistachioEvent.responses || {}), [playerId]: 'ate'};
          const allResponded = gameState.goldenPistachioEvent.playersNeedingResponse.every(pid => responses[pid]);
          if (allResponded) {
            updates['goldenPistachioEvent'] = null;
          }
        } else if (gameState.hungerMarker) {
          updates['hungerMarker'] = true;
        } else {
          updates['hungerMarker'] = true;
        }
        
        await database.ref(`games/${roomCode}`).update(updates);
        
        setMultiEatMode(false);
        setSelectedEdibleIndices([]);
        if (cardsToEat.length >= 2) {
          setError(`Ate ${cardsToEat.length} foods and gained 1 energy token!`);
        }
      };

      const playCard = async (cardIndex) => {
        if (!gameState) return;
        
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        const currentPlayer = players[gameState.currentPlayerIndex];
        if (currentPlayer.id !== playerId) return;

        const myPlayer = gameState.players[playerId];
        
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        if (overCount > 0 && !(gameState.pendingAction?.type === 'moldy')) {
          setError('You must pay the overencumbered penalty first!');
          return;
        }
        
        const card = myPlayer.hand[cardIndex];
        if (!card) return;

        // Shells cannot be played - only discarded via shell bowl
        if (card.type === 'shell') {
          setError('Shells cannot be played! Use the Shell Bowl to discard them.');
          return;
        }

        if (card.type === 'caffeinated') {
          setSelectedCaffeineIndex(cardIndex);
          setError('Caffeine selected! Now click another card to play it caffeinated.');
          return;
        }

        const isCaffeinated = selectedCaffeineIndex !== null;
        let newHand = myPlayer.hand.filter((_, i) => i !== cardIndex);
        const cardsToDiscard = [card];
        
        if (isCaffeinated) {
          const caffeineCard = myPlayer.hand[selectedCaffeineIndex];
          newHand = newHand.filter(c => c.id !== caffeineCard.id);
          cardsToDiscard.push(caffeineCard);
          setSelectedCaffeineIndex(null);
        }

        const newDiscard = [...(gameState.discardPile || []), ...cardsToDiscard];

        // Most cards can be slapped, with special rules for gorillas
const canBeSlapped = !['golden', 'nutcracker', 'caffeinated'].includes(card.type);

// Special case: gorillas can only be slapped with caffeine
const isGorillaRequiringCaffeine = card.type === 'gorilla' && !isCaffeinated;
        
        if (canBeSlapped && !isGorillaRequiringCaffeine) {
          const slapWindowData = {
            playerId: playerId,
            playerName: myPlayer.name,
            card: card,
            cardIndex: cardIndex,
            isCaffeinated: isCaffeinated,
            cardsToDiscard: cardsToDiscard,
            newHand: newHand,
            timestamp: Date.now(),
            canBeSlapped: true,
            requiresCaffeine: card.type === 'gorilla'  // Flag that gorilla needs caffeine to slap
          };
          
          await database.ref(`games/${roomCode}/slapWindow`).set(slapWindowData);
          
          setTimeout(async () => {
            const currentState = await database.ref(`games/${roomCode}/slapWindow`).once('value');
            const slapData = currentState.val();
            if (slapData && slapData.timestamp === slapWindowData.timestamp) {
              await database.ref(`games/${roomCode}/slapWindow`).set(null);
              await executeCardLogic(card, isCaffeinated, newHand, newDiscard);
            }
          }, 4000);
          
          return;
        }

        if (card.type === 'slap') {
          if (gameState.slapWindow && gameState.slapWindow.canBeSlapped) {
            const targetWasCaffeinated = gameState.slapWindow.isCaffeinated;
            const targetRequiresCaffeine = gameState.slapWindow.requiresCaffeine;
            
            if (targetWasCaffeinated && !isCaffeinated) {
              setError('Cannot slap a caffeinated card without caffeine!');
              return;
            }
            
            if (targetRequiresCaffeine && !isCaffeinated) {
              setError('Cannot slap a Gorilla without caffeine!');
              return;
            }
            
            await database.ref(`games/${roomCode}`).update({
              [`players/${playerId}/hand`]: newHand,
              discardPile: [...(gameState.discardPile || []), ...gameState.slapWindow.cardsToDiscard, ...cardsToDiscard],
              [`players/${gameState.slapWindow.playerId}/hand`]: gameState.slapWindow.newHand,
              slapWindow: null
            });
            
            setError(`Slapped ${gameState.slapWindow.playerName}'s ${gameState.slapWindow.card.type}!`);
            return;
          } else {
            setError('No card to slap right now!');
            return;
          }
        }

        await executeCardLogic(card, isCaffeinated, newHand, newDiscard);
      };

      const executeCardLogic = async (card, isCaffeinated, newHand, newDiscard) => {
        const myPlayer = gameState.players[playerId];
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        
        if (card.type === 'spillBowl') {
          const shellBowl = gameState.shellBowl || [];
          const updates = {};
          
          if (isCaffeinated) {
            shellBowl.forEach(colorIndex => {
              if (colorIndex !== myPlayer.colorIndex) {
                const player = Object.values(gameState.players).find(p => p.colorIndex === colorIndex);
                if (player) {
                  updates[`players/${player.id}/energyTokens`] = Math.min(10, player.energyTokens + 1);
                }
              }
            });
            updates['shellBowl'] = shellBowl.filter(c => c === myPlayer.colorIndex);
          } else {
            shellBowl.forEach(colorIndex => {
              const player = Object.values(gameState.players).find(p => p.colorIndex === colorIndex);
              if (player) {
                updates[`players/${player.id}/energyTokens`] = Math.min(10, player.energyTokens + 1);
              }
            });
            updates['shellBowl'] = [];
          }
          
          updates[`players/${playerId}/hand`] = newHand;
          updates['discardPile'] = newDiscard;
          
          await database.ref(`games/${roomCode}`).update(updates);
          return;
        }

        if (card.type === 'donate') {
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            pendingAction: {
              type: 'donate',
              playerId: playerId,
              cardsToGive: isCaffeinated ? 2 : 1
            }
          });
          return;
        }

        if (card.type === 'fast') {
          const updates = {
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
            turnPhase: 'draw',
            hungerMarker: true
          };
          
          if (isCaffeinated) {
            const cardsToDraw = myPlayer.tools?.includes('gorilla') ? 2 : 1;
            const newDeck = [...gameState.deck];
            const drawnCards = newDeck.splice(0, Math.min(cardsToDraw, newDeck.length));
            const handWithDrawn = [...newHand, ...drawnCards];
            
            updates[`players/${playerId}/hand`] = handWithDrawn;
            updates['deck'] = newDeck;
          }
          
          await database.ref(`games/${roomCode}`).update(updates);
          return;
        }

        if (card.type === 'picky') {
          const cardsToView = isCaffeinated ? 4 : 3;
          const topCards = gameState.deck.slice(0, cardsToView);
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            pendingAction: {
              type: 'picky',
              playerId: playerId,
              topCards: topCards,
              isCaffeinated: isCaffeinated,
              hasGorilla: myPlayer.tools?.includes('gorilla') || false,
              reorderedCards: null
            }
          });
          return;
        }

        if (card.type === 'raccoon') {
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            pendingAction: {
              type: 'raccoon',
              playerId: playerId,
              isCaffeinated: isCaffeinated,
              action: null
            }
          });
          return;
        }

        if (card.category === 'tool') {
          const newTools = [...(myPlayer.tools || []), card.type];
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            [`players/${playerId}/tools`]: newTools
          });
          return;
        }
        
        // Golden shells can be played from hand
        if (card.type === 'goldenShell') {
          const newGoldenShells = [...(myPlayer.goldenShells || []), card];
          
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            [`players/${playerId}/goldenShells`]: newGoldenShells,
            discardPile: newDiscard
          });
          
          if (newGoldenShells.length >= 3) {
            await database.ref(`games/${roomCode}`).update({
              status: 'finished',
              winner: playerId,
              winType: 'golden'
            });
          }
          return;
        }

        if (card.category === 'edible') {
          // Check if this is being discarded for moldy (not eaten)
          const isDiscardingForMoldy = gameState.pendingAction?.type === 'moldy' && gameState.pendingAction.playerId === playerId;
          
          if (card.type === 'pesky' && !myPlayer.tools?.includes('nutcracker') && !isDiscardingForMoldy) {
            setError('Cannot eat Pesky Pistachio without a Nutcracker!');
            return;
          }
          
          const updates = {
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard
          };
          
          // Loose pistachios add bonus draws at end of turn ONLY if eaten (not discarded for moldy)
          if (card.type === 'loose' && !isDiscardingForMoldy) {
            const currentBonus = myPlayer.looseBonusDraws || 0;
            updates[`players/${playerId}/looseBonusDraws`] = currentBonus + 1;
          }
          
          if (isDiscardingForMoldy) {
            // Discarding for moldy - end turn, NO hunger event
            const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
            updates['currentPlayerIndex'] = (gameState.currentPlayerIndex + 1) % players.length;
            updates['pendingAction'] = null;
            // Do NOT set hungerMarker - this is discarding, not eating
          }
          else if (gameState.goldenPistachioEvent && 
              gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
              !gameState.goldenPistachioEvent.responses?.[playerId]) {
            updates[`goldenPistachioEvent/responses/${playerId}`] = 'ate';
            
            const responses = {...(gameState.goldenPistachioEvent.responses || {}), [playerId]: 'ate'};
            const allResponded = gameState.goldenPistachioEvent.playersNeedingResponse.every(pid => responses[pid]);
            if (allResponded) {
              updates['goldenPistachioEvent'] = null;
            }
          } else if (gameState.hungerMarker) {
            updates['hungerMarker'] = true;
          } else {
            updates['hungerMarker'] = true;
          }
          
          await database.ref(`games/${roomCode}`).update(updates);

          if (card.type === 'golden') {
            const newGoldenDeck = [...(gameState.goldenDeck || [])];
            const goldenShell = newGoldenDeck.shift();
            if (goldenShell) {
              const newGoldenShells = [...(myPlayer.goldenShells || []), goldenShell];
              await database.ref(`games/${roomCode}`).update({
                [`players/${playerId}/goldenShells`]: newGoldenShells,
                goldenDeck: newGoldenDeck
              });

              if (newGoldenShells.length >= 3) {
                await database.ref(`games/${roomCode}`).update({
                  status: 'finished',
                  winner: playerId,
                  winType: 'golden'
                });
                return;
              }
            }

            const otherPlayers = Object.keys(gameState.players).filter(pid => 
              pid !== playerId && 
              gameState.players[pid].connected && 
              !gameState.players[pid].eliminated
            );
            
            if (otherPlayers.length > 0) {
              await database.ref(`games/${roomCode}`).update({
                goldenPistachioEvent: {
                  playedBy: playerId,
                  playersNeedingResponse: otherPlayers,
                  responses: {}
                }
              });
            }
          } else if (card.type === 'raisin') {
            const newTokens = Math.min(10, myPlayer.energyTokens + 1);
            await database.ref(`games/${roomCode}/players/${playerId}/energyTokens`).set(newTokens);
          }
          return;
        }

        await database.ref(`games/${roomCode}`).update({
          [`players/${playerId}/hand`]: newHand,
          discardPile: newDiscard
        });
      };

      const useShellBowl = async () => {
        if (!gameState) return;
        
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        const currentPlayer = players[gameState.currentPlayerIndex];
        if (currentPlayer.id !== playerId) return;

        const myPlayer = gameState.players[playerId];
        
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        if (overCount > 0) {
          setError('You must pay the overencumbered penalty first!');
          return;
        }
        
        if (!shellBowlMode) {
          if (myPlayer.energyTokens <= 0) {
            setError('No energy tokens left!');
            return;
          }
          if ((gameState.shellBowl || []).length >= 5) {
            setError('Shell bowl is full!');
            return;
          }
          
          setShellBowlMode(true);
          setSelectedShellIndices([]);
          setError('Select cards to discard, then click "Confirm Discard"');
          return;
        } else {
          if (selectedShellIndices.length === 0) {
            setError('Select at least one card to discard!');
            return;
          }
          
          const cardsToDiscard = selectedShellIndices.map(idx => myPlayer.hand[idx]);
          const newHand = myPlayer.hand.filter((_, idx) => !selectedShellIndices.includes(idx));
          const newShellBowl = [...(gameState.shellBowl || []), myPlayer.colorIndex];
          const newTokens = myPlayer.energyTokens - 1;

          const updates = {
            [`players/${playerId}/hand`]: newHand,
            [`players/${playerId}/energyTokens`]: newTokens,
            tokenBowl: (gameState.tokenBowl || 0) + 1,
            shellBowl: newShellBowl,
            discardPile: [...(gameState.discardPile || []), ...cardsToDiscard]
          };

          if (newTokens === 0) {
            const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
            updates[`players/${playerId}/eliminated`] = true;
            
            // Discard tools and golden shells
            const deadPlayerHand = myPlayer.hand || [];
            const deadPlayerTools = myPlayer.tools || [];
            const deadPlayerGoldenShells = myPlayer.goldenShells || [];
            
            const toolsAndShells = [...deadPlayerTools.map(t => ({ type: t, category: 'tool', id: `${t}-discarded` })), 
                                     ...deadPlayerGoldenShells];
            
            // Distribute hand to players counter-clockwise starting from previous player
            const currentIndex = gameState.currentPlayerIndex;
            const previousIndex = (currentIndex - 1 + players.length) % players.length;
            
            let cardIndex = 0;
            for (let i = 0; i < players.length - 1; i++) {
              const playerIndex = (previousIndex - i + players.length) % players.length;
              const targetPlayer = players[playerIndex];
              if (targetPlayer.id !== playerId && cardIndex < deadPlayerHand.length) {
                const cardToGive = deadPlayerHand[cardIndex];
                updates[`players/${targetPlayer.id}/hand`] = [...(targetPlayer.hand || []), cardToGive];
                cardIndex++;
              }
            }
            
            // Rest of hand goes to discard
            const remainingCards = deadPlayerHand.slice(cardIndex);
            updates['discardPile'] = [...(gameState.discardPile || []), ...toolsAndShells, ...remainingCards];
            
            const remainingPlayers = players.filter(p => p.id !== playerId);
            if (remainingPlayers.length === 1) {
              updates['status'] = 'finished';
              updates['winner'] = remainingPlayers[0].id;
              updates['winType'] = 'lastStanding';
            }
          }

          await database.ref(`games/${roomCode}`).update(updates);
          
          setShellBowlMode(false);
          setSelectedShellIndices([]);
          setError('');
        }
      };

      const leaveGame = async () => {
        if (roomCode && playerId) {
          await database.ref(`games/${roomCode}/players/${playerId}/connected`).set(false);
        }
        setScreen('menu');
        setRoomCode('');
        setGameState(null);
      };

      const copyRoomCode = () => {
        navigator.clipboard.writeText(roomCode);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      };

      if (screen === 'menu') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-amber-900 via-yellow-800 to-amber-900 flex items-center justify-center p-4">
            <div className="bg-amber-50 rounded-3xl shadow-2xl p-8 max-w-md w-full border-4 border-amber-900">
              <div className="text-center mb-8">
                <h1 className="text-5xl font-black text-amber-900 mb-2">PISTACHIO</h1>
                <p className="text-amber-700 font-medium">Online Multiplayer Card Game</p>
                <button
                  onClick={() => setShowRules(true)}
                  className="mt-2 text-amber-600 hover:text-amber-800 text-sm underline"
                >
                  üìñ View Rules
                </button>
              </div>

              {error && (
                <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl mb-4 text-sm">
                  {error}
                </div>
              )}

              <div className="space-y-4 mb-6">
                <input
                  type="text"
                  placeholder="Enter your name"
                  value={playerName}
                  onChange={(e) => setPlayerName(e.target.value)}
                  className="w-full px-4 py-3 rounded-xl border-2 border-amber-300 focus:border-amber-500 focus:outline-none text-lg"
                  maxLength={20}
                />
              </div>

              <div className="space-y-3">
                <button
                  onClick={createGame}
                  disabled={!playerName.trim()}
                  className="w-full bg-amber-600 hover:bg-amber-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-bold py-4 rounded-xl transition-colors text-lg"
                >
                  üë• Create Game
                </button>

                <div className="relative">
                  <div className="absolute inset-0 flex items-center">
                    <div className="w-full border-t border-amber-300"></div>
                  </div>
                  <div className="relative flex justify-center text-sm">
                    <span className="px-2 bg-amber-50 text-amber-600 font-medium">OR</span>
                  </div>
                </div>

                <input
                  type="text"
                  placeholder="Enter room code"
                  value={joinCode}
                  onChange={(e) => setJoinCode(e.target.value.toUpperCase())}
                  className="w-full px-4 py-3 rounded-xl border-2 border-amber-300 focus:border-amber-500 focus:outline-none text-lg text-center font-bold uppercase"
                  maxLength={6}
                />

                <button
                  onClick={joinGame}
                  disabled={!playerName.trim() || !joinCode.trim()}
                  className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-bold py-4 rounded-xl transition-colors text-lg"
                >
                  ‚ñ∂Ô∏è Join Game
                </button>
              </div>
            </div>
            
            {showRules && (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-amber-50 rounded-2xl shadow-2xl max-w-4xl w-full max-h-screen overflow-y-auto border-4 border-amber-900">
                  <div className="sticky top-0 bg-amber-900 text-amber-50 p-4 flex justify-between items-center">
                    <h2 className="text-2xl font-black">üìñ PISTACHIO RULES</h2>
                    <button
                      onClick={() => setShowRules(false)}
                      className="bg-amber-700 hover:bg-amber-600 text-white px-4 py-2 rounded-lg font-bold"
                    >
                      ‚úï Close
                    </button>
                  </div>
                  <div className="p-6 space-y-6">
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üéØ OBJECTIVE</h3>
                      <p className="text-amber-800">Be the first to collect 3 Golden Shells OR be the last player standing!</p>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üéÆ TURN STRUCTURE</h3>
                      <ol className="list-decimal list-inside space-y-2 text-amber-800">
                        <li><strong>Overencumbered Check:</strong> If over hand limit, MUST pay 1 energy token per card over.</li>
                        <li><strong>Hunger Event:</strong> If hunger marker is on deck, must eat food OR pay 1 energy token.</li>
                        <li><strong>Play Cards:</strong> Play as many cards as you want.</li>
                        <li><strong>Shell Bowl:</strong> Pay 1 energy token to discard cards.</li>
                        <li><strong>Draw Card:</strong> Draw 1 card to end turn (2 if you have Gorilla).</li>
                      </ol>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üçΩÔ∏è EATING FOOD</h3>
                      <ul className="list-disc list-inside space-y-1 text-amber-800">
                        <li>Eating 1 food: Places Hunger marker for next player</li>
                        <li>Eating 2+ foods: Gain 1 energy token!</li>
                        <li><strong>Pesky Pistachio:</strong> Requires Nutcracker to eat</li>
                        <li><strong>Golden Pistachio:</strong> Draw a Golden Shell. All other players must eat or lose 1 energy!</li>
                        <li><strong>Raisin:</strong> Gain 1 energy token</li>
                        <li><strong>Loose Pistachio:</strong> Draw 1 extra card when drawn</li>
                      </ul>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üÉè SPECIAL CARDS</h3>
                      <div className="space-y-2 text-amber-800 text-sm">
                        <div><strong>‚òï Caffeinated:</strong> Enhances another card</div>
                        <div><strong>üëã Slap:</strong> Cancel another player's card (4-second window)</div>
                        <div><strong>ü¶ù Raccoon:</strong> Steal 1 random card (2 if caffeinated)</div>
                        <div><strong>üéÅ Donate:</strong> Give 1 card to opponent (2 if caffeinated)</div>
                        <div><strong>üîç Picky:</strong> View top 3 cards and reorder (4 if caffeinated). With Gorilla: Pick 2 cards instead of 1!</div>
                        <div><strong>‚ö° Fast:</strong> Skip turn and continue hunger event (draw cards if caffeinated)</div>
                        <div><strong>üåä Spill Bowl:</strong> Return all energy tokens from shell bowl to players</div>
                        <div><strong>ü¶† Moldy:</strong> Forces you to discard edible/tool or reveal hand</div>
                      </div>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üí° TIPS</h3>
                      <ul className="list-disc list-inside space-y-1 text-amber-800">
                        <li>Right-click any card in your hand to zoom in</li>
                        <li>Watch for slap windows when opponents play cards</li>
                        <li>Eat multiple foods at once to regain energy</li>
                        <li>Golden Shells increase your hand limit</li>
                      </ul>
                    </section>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      if (screen === 'lobby' && gameState) {
        const players = Object.values(gameState.players);
        return (
          <div className="min-h-screen bg-gradient-to-br from-amber-900 via-yellow-800 to-amber-900 flex items-center justify-center p-4">
            <div className="bg-amber-50 rounded-3xl shadow-2xl p-8 max-w-2xl w-full border-4 border-amber-900">
              <div className="flex justify-between items-start mb-6">
                <div className="text-center flex-1">
                  <h2 className="text-3xl font-black text-amber-900 mb-2">Game Lobby</h2>
                  <div className="flex items-center justify-center gap-2 mb-4">
                    <div className="bg-amber-900 text-amber-50 px-6 py-2 rounded-xl text-2xl font-black tracking-wider">
                      {roomCode}
                    </div>
                    <button
                      onClick={copyRoomCode}
                      className="p-2 bg-amber-600 hover:bg-amber-700 text-white rounded-lg transition-colors"
                    >
                      {copied ? '‚úì' : 'üìã'}
                    </button>
                  </div>
                  <p className="text-amber-700">Share this code with your friends!</p>
                  <button
                    onClick={() => setShowRules(true)}
                    className="mt-2 text-amber-600 hover:text-amber-800 text-sm underline"
                  >
                    üìñ View Rules
                  </button>
                </div>
                <button
                  onClick={leaveGame}
                  className="p-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
                >
                  üö™
                </button>
              </div>

              {error && (
                <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl mb-4 text-sm">
                  {error}
                </div>
              )}

              <div className="bg-white rounded-xl p-6 mb-6">
                <h3 className="font-bold text-xl text-amber-900 mb-4">Players ({players.length}/4)</h3>
                <div className="space-y-2">
                  {players.map((player) => (
                    <div key={player.id} className={`flex items-center gap-3 p-3 rounded-lg ${player.connected ? 'bg-amber-50' : 'bg-gray-200 opacity-60'}`}>
                      <div 
                        className="w-8 h-8 rounded-full" 
                        style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                      />
                      <span className="font-bold text-lg">{player.name}</span>
                      {!player.connected && (
                        <span className="ml-auto bg-gray-500 text-white px-2 py-1 rounded text-xs font-bold">
                          DISCONNECTED
                        </span>
                      )}
                      {player.id === gameState.host && (
                        <span className="ml-auto bg-amber-600 text-white px-2 py-1 rounded text-xs font-bold">
                          HOST
                        </span>
                      )}
                    </div>
                  ))}
                </div>
              </div>

              {playerId === gameState.host && (
                <button
                  onClick={startGame}
                  disabled={players.length < 3}
                  className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-4 rounded-xl transition-colors text-lg"
                >
                  {players.length < 3 
                    ? `Need ${3 - players.length} more player(s)` 
                    : 'üéÆ Start Game'}
                </button>
              )}

              {playerId !== gameState.host && (
                <div className="text-center text-amber-700 font-medium">
                  Waiting for host to start the game...
                </div>
              )}
            </div>
            
            {showRules && (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-amber-50 rounded-2xl shadow-2xl max-w-4xl w-full max-h-screen overflow-y-auto border-4 border-amber-900">
                  <div className="sticky top-0 bg-amber-900 text-amber-50 p-4 flex justify-between items-center">
                    <h2 className="text-2xl font-black">üìñ PISTACHIO RULES</h2>
                    <button
                      onClick={() => setShowRules(false)}
                      className="bg-amber-700 hover:bg-amber-600 text-white px-4 py-2 rounded-lg font-bold"
                    >
                      ‚úï Close
                    </button>
                  </div>
                  <div className="p-6 space-y-6">
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üéØ OBJECTIVE</h3>
                      <p className="text-amber-800">Be the first to collect 3 Golden Shells OR be the last player standing!</p>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üéÆ TURN STRUCTURE</h3>
                      <ol className="list-decimal list-inside space-y-2 text-amber-800">
                        <li><strong>Overencumbered Check:</strong> If over hand limit, MUST pay 1 energy token per card over.</li>
                        <li><strong>Hunger Event:</strong> If hunger marker is on deck, must eat food OR pay 1 energy token.</li>
                        <li><strong>Play Cards:</strong> Play as many cards as you want.</li>
                        <li><strong>Shell Bowl:</strong> Pay 1 energy token to discard cards.</li>
                        <li><strong>Draw Card:</strong> Draw 1 card to end turn (2 if you have Gorilla).</li>
                      </ol>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üçΩÔ∏è EATING FOOD</h3>
                      <ul className="list-disc list-inside space-y-1 text-amber-800">
                        <li>Eating 1 food: Places Hunger marker for next player</li>
                        <li>Eating 2+ foods: Gain 1 energy token!</li>
                        <li><strong>Pesky Pistachio:</strong> Requires Nutcracker to eat</li>
                        <li><strong>Golden Pistachio:</strong> Draw a Golden Shell. All other players must eat or lose 1 energy!</li>
                        <li><strong>Raisin:</strong> Gain 1 energy token</li>
                        <li><strong>Loose Pistachio:</strong> Draw 1 extra card when drawn</li>
                      </ul>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üÉè SPECIAL CARDS</h3>
                      <div className="space-y-2 text-amber-800 text-sm">
                        <div><strong>‚òï Caffeinated:</strong> Enhances another card</div>
                        <div><strong>üëã Slap:</strong> Cancel another player's card (4-second window)</div>
                        <div><strong>ü¶ù Raccoon:</strong> Steal 1 random card (2 if caffeinated)</div>
                        <div><strong>üéÅ Donate:</strong> Give 1 card to opponent (2 if caffeinated)</div>
                        <div><strong>üîç Picky:</strong> View top 3 cards and reorder (4 if caffeinated). With Gorilla: Pick 2 cards instead of 1!</div>
                        <div><strong>‚ö° Fast:</strong> Skip turn and continue hunger event (draw cards if caffeinated)</div>
                        <div><strong>üåä Spill Bowl:</strong> Return all energy tokens from shell bowl to players</div>
                        <div><strong>ü¶† Moldy:</strong> Forces you to discard edible/tool or reveal hand</div>
                      </div>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üí° TIPS</h3>
                      <ul className="list-disc list-inside space-y-1 text-amber-800">
                        <li>Right-click any card in your hand to zoom in</li>
                        <li>Watch for slap windows when opponents play cards</li>
                        <li>Eat multiple foods at once to regain energy</li>
                        <li>Golden Shells increase your hand limit</li>
                      </ul>
                    </section>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

if (screen === 'game' && gameState) {
        const players = gameState.players ? Object.values(gameState.players).filter(p => p.connected && !p.eliminated) : [];
        const currentPlayer = players.length > 0 && gameState.currentPlayerIndex < players.length ? players[gameState.currentPlayerIndex] : null;
        const myPlayer = gameState.players ? gameState.players[playerId] : null;
        const isMyTurn = currentPlayer?.id === playerId;

        // Fix undefined arrays
        if (myPlayer) {
          if (!myPlayer.hand) myPlayer.hand = [];
          if (!myPlayer.tools) myPlayer.tools = [];
          if (!myPlayer.goldenShells) myPlayer.goldenShells = [];
        }

        if (gameState.status === 'finished') {
          const winner = gameState.players[gameState.winner];
          return (
            <div className="min-h-screen bg-gradient-to-br from-yellow-400 via-yellow-500 to-yellow-600 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-12 max-w-2xl w-full border-4 border-yellow-700 text-center">
                <h1 className="text-6xl font-black text-yellow-900 mb-4">üéâ GAME OVER! üéâ</h1>
                <h2 className="text-4xl font-bold text-yellow-800 mb-8">{winner?.name} WINS!</h2>
                <p className="text-xl text-gray-700 mb-8">
                  {gameState.winType === 'golden' ? '‚ú® Collected 3 Golden Shells!' : gameState.winType === 'lastStanding' ? 'üí™ Last Player Standing!' : 'Victory!'}
                </p>
                <button
                  onClick={() => {
                    setScreen('menu');
                    setRoomCode('');
                    setGameState(null);
                  }}
                  className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-4 px-8 rounded-xl text-lg"
                >
                  Back to Menu
                </button>
              </div>
            </div>
          );
        }

        if (!myPlayer) {
          return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-green-900 p-4 flex items-center justify-center">
              <div className="text-white text-center">
                <h1 className="text-4xl font-bold mb-4">Loading...</h1>
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-green-900 p-4">
            <div className="max-w-7xl mx-auto">
              <div className="bg-amber-50 rounded-2xl shadow-lg p-4 mb-4 border-2 border-amber-900">
                <div className="flex justify-between items-center">
                  <div>
                    <h1 className="text-2xl font-black text-amber-900">PISTACHIO</h1>
                    <p className="text-sm text-amber-700">Room: {roomCode}</p>
                  </div>
                  <div className="text-center flex-1">
                    <div className="text-lg font-bold text-amber-900">
                      {isMyTurn ? "üî• YOUR TURN üî•" : `${currentPlayer?.name}'s Turn`}
                    </div>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() => setShowRules(true)}
                      className="p-2 bg-amber-600 hover:bg-amber-700 text-white rounded-lg transition-colors text-sm"
                    >
                      üìñ
                    </button>
                    <button
                      onClick={leaveGame}
                      className="p-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
                    >
                      üö™
                    </button>
                  </div>
                </div>
              </div>

              {error && (
                <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl mb-4 text-sm">
                  {error}
                </div>
              )}

              {gameState.revealedHand && (
                <div className="bg-purple-50 border-2 border-purple-400 rounded-xl p-4 mb-4">
                  <div className="text-center">
                    <h4 className="text-lg font-bold text-purple-900">üëÅÔ∏è HAND REVEALED! üëÅÔ∏è</h4>
                    <p className="text-sm text-purple-700 mb-2">
                      {gameState.revealedHand.playerName} had no edibles or tools for the Moldy Pistachio!
                    </p>
                    <div className="flex gap-2 justify-center flex-wrap">
                      {gameState.revealedHand.cards.map((card, i) => (
                        <div key={i} className="bg-white px-3 py-1 rounded border-2 border-purple-300 text-sm font-bold">
                          {card.type}
                        </div>
                      ))}
                      {gameState.revealedHand.cards.length === 0 && (
                        <div className="text-sm text-purple-600 italic">Empty hand</div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {gameState.slapWindow && gameState.slapWindow.playerId !== playerId && (
                <div className="bg-red-50 border-4 border-red-600 rounded-xl p-4 mb-4 animate-pulse">
                  <div className="text-center">
                    <h4 className="text-2xl font-black text-red-900">üëã SLAP OPPORTUNITY! üëã</h4>
                    <p className="text-sm text-red-700 mt-1 mb-3">
                      {gameState.slapWindow.playerName} is playing: <span className="font-bold">{gameState.slapWindow.card.type.toUpperCase()}</span>
                      {gameState.slapWindow.isCaffeinated && <span className="text-yellow-600"> (‚òï CAFFEINATED)</span>}
                    </p>
                    {(() => {
                      const myHand = gameState.players[playerId]?.hand || [];
                      const hasSlap = myHand.some(c => c.type === 'slap');
                      const hasCaffeine = myHand.some(c => c.type === 'caffeinated');
                      const canSlap = hasSlap && (!gameState.slapWindow.isCaffeinated || hasCaffeine);
                      
                      if (canSlap) {
                        return (
                          <button
                            onClick={async () => {
                              const slapCard = myHand.find(c => c.type === 'slap');
                              const slapIndex = myHand.findIndex(c => c.type === 'slap');
                              if (slapCard) {
                                await playCard(slapIndex);
                              }
                            }}
                            className="bg-red-600 hover:bg-red-700 text-white font-black text-xl py-4 px-8 rounded-xl transition-all transform hover:scale-110"
                          >
                            üëã SLAP IT!
                          </button>
                        );
                      } else if (!hasSlap) {
                        return <p className="text-xs text-red-600">You don't have a Slap card</p>;
                      } else if (gameState.slapWindow.isCaffeinated && !hasCaffeine) {
                        return <p className="text-xs text-red-600">Need Caffeine to slap a caffeinated card!</p>;
                      }
                    })()}
                  </div>
                </div>
              )}

              <div className="grid grid-cols-3 gap-4 mb-4">
                <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                  <h3 className="font-bold text-amber-900 mb-2">Main Deck</h3>
                  <div className="relative">
                    <div className="w-32 h-44 bg-gradient-to-br from-amber-700 to-amber-900 rounded-lg shadow-lg flex items-center justify-center border-4 border-amber-950 overflow-hidden">
                      <img 
                        src="images/cards/cardBack.PNG" 
                        alt="Card Back" 
                        className="w-full h-full object-cover"
                        onError={(e) => {
                          e.target.style.display = 'none';
                          e.target.nextSibling.style.display = 'flex';
                        }}
                      />
                      <div className="text-white font-black text-4xl absolute" style={{display: 'none'}}>
                        {gameState.deck?.length || 0}
                      </div>
                    </div>
                    <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-sm font-bold">
                      {gameState.deck?.length || 0}
                    </div>
                    {gameState.hungerMarker && (
                      <div className="absolute -top-2 -right-2 bg-red-600 text-white px-3 py-1 rounded-full text-xs font-bold animate-pulse">
                        HUNGER
                      </div>
                    )}
                  </div>
                </div>

                <div className="space-y-4">
                  <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                    <h3 className="font-bold text-amber-900 mb-2">Discard</h3>
                    <div className="w-32 h-44 bg-gray-300 rounded-lg shadow-lg flex items-center justify-center border-2 border-gray-400 overflow-hidden">
                      {gameState.discardPile?.length > 0 ? (
                        <img 
                          src={CARD_IMAGES[gameState.discardPile[gameState.discardPile.length - 1].type] || 'images/cards/cardBack.PNG'}
                          alt={gameState.discardPile[gameState.discardPile.length - 1].type}
                          className="w-full h-full object-cover"
                          onError={(e) => {
                            e.target.style.display = 'none';
                            e.target.nextSibling.style.display = 'block';
                          }}
                        />
                      ) : null}
                      <div className="text-gray-500 text-sm" style={{display: gameState.discardPile?.length > 0 ? 'none' : 'block'}}>
                        Empty
                      </div>
                    </div>
                  </div>

                  <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                    <h3 className="font-bold text-amber-900 mb-2">Shell Bowl</h3>
                    <div className="flex gap-1">
                      {[0,1,2,3,4].map(i => (
                        <div 
                          key={i}
                          className="w-6 h-6 rounded-full border-2"
                          style={
                            i < (gameState.shellBowl?.length || 0)
                              ? { backgroundColor: PLAYER_COLORS[gameState.shellBowl[i]], borderColor: '#78350f' }
                              : { backgroundColor: 'white', borderColor: '#fbbf24' }
                          }
                        />
                      ))}
                    </div>
                    <div className="text-xs text-amber-700 mt-1">{gameState.shellBowl?.length || 0}/5</div>
                  </div>
                  
                  <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                    <h3 className="font-bold text-amber-900 mb-2">Token Bowl</h3>
                    <div className="text-center">
                      <div className="text-3xl font-black text-amber-900">{gameState.tokenBowl || 0}</div>
                      <div className="text-xs text-amber-700">‚ö° Tokens</div>
                    </div>
                  </div>
                </div>

                <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                  <h3 className="font-bold text-amber-900 mb-2">Golden Shells</h3>
                  <div className="relative">
                    <div className="w-32 h-44 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-lg shadow-lg flex items-center justify-center border-4 border-yellow-700 overflow-hidden">
                      <img 
                        src="images/cards/goldenShell.PNG" 
                        alt="Golden Shell" 
                        className="w-full h-full object-cover"
                        onError={(e) => {
                          e.target.style.display = 'none';
                          e.target.nextSibling.style.display = 'flex';
                        }}
                      />
                      <div className="text-yellow-900 font-black text-4xl absolute" style={{display: 'none'}}>
                        {gameState.goldenDeck?.length || 0}
                      </div>
                    </div>
                    <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-sm font-bold">
                      {gameState.goldenDeck?.length || 0}
                    </div>
                  </div>
                </div>
              </div>

              <div className="grid grid-cols-3 gap-4 mb-4">
                {players && players.filter(p => p.id !== playerId).map((player) => (
                  <div key={player.id} className={`bg-amber-50 rounded-xl p-4 border-2 border-amber-900 ${!player.connected ? 'opacity-50' : ''}`}>
                    <div className="flex items-center gap-2 mb-2">
                      <div 
                        className="w-6 h-6 rounded-full" 
                        style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                      />
                      <h3 className="font-bold text-amber-900">{player.name}</h3>
                      {!player.connected && (
                        <span className="ml-auto text-xs bg-gray-500 text-white px-1 py-0.5 rounded">DC</span>
                      )}
                    </div>
                    <div className="text-sm space-y-1">
                      <div>‚ö° Energy: {player.energyTokens}/10</div>
                      <div>üÉè Cards: {player.hand?.length || 0}</div>
                      <div>‚ú® Golden: {player.goldenShells?.length || 0}</div>
                      {player.tools && player.tools.length > 0 && (
                        <div className="flex gap-1 mt-2 flex-wrap">
                          {player.tools.map((tool, i) => (
                            <div key={i} className="text-xs bg-amber-200 px-2 py-1 rounded">
                              {tool}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>

              {myPlayer && (
                <div className="bg-amber-50 rounded-2xl p-6 border-4 border-amber-900">
                  <div className="flex justify-between items-center mb-4">
                    <div className="flex items-center gap-3">
                      <div 
                        className="w-8 h-8 rounded-full" 
                        style={{ backgroundColor: PLAYER_COLORS[myPlayer.colorIndex] }}
                      />
                      <h3 className="font-bold text-xl text-amber-900">{myPlayer.name} (You)</h3>
                    </div>
                    <div className="flex items-center gap-4">
                      <div className="text-right">
                        <div className="text-sm text-amber-700">Energy</div>
                        <div className="text-2xl font-black text-amber-900">{myPlayer.energyTokens}/10</div>
                      </div>
                      {myPlayer.goldenShells && myPlayer.goldenShells.length > 0 && (
                        <div className="text-right">
                          <div className="text-sm text-amber-700">Golden Shells</div>
                          <div className="text-2xl font-black text-yellow-600">{myPlayer.goldenShells.length}/3</div>
                        </div>
                      )}
                    </div>
                  </div>

                  {myPlayer.goldenShells && myPlayer.goldenShells.length > 0 && (
                    <div className="mb-4">
                      <div className="text-sm text-amber-700 mb-2">Your Golden Shells:</div>
                      <div className="flex gap-2">
                        {myPlayer.goldenShells.map((shell, i) => (
                          <div key={i} className="w-16 h-20 rounded-lg overflow-hidden border-2 border-yellow-600 shadow-lg">
                            <img 
                              src="images/cards/goldenShell.PNG" 
                              alt="Golden Shell" 
                              className="w-full h-full object-cover"
                            />
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {myPlayer.tools && myPlayer.tools.length > 0 && (
                    <div className="mb-4">
                      <div className="text-sm text-amber-700 mb-2">Tools in Play:</div>
                      <div className="flex gap-2">
                        {myPlayer.tools.map((tool, i) => (
                          <div key={i} className="w-16 h-20 rounded-lg overflow-hidden border-2 border-amber-600 shadow-lg">
                            <img 
                              src={CARD_IMAGES[tool]}
                              alt={tool}
                              className="w-full h-full object-cover"
                            />
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {isMyTurn && myPlayer.hand && !gameState.pendingAction && !gameState.goldenPistachioEvent && !gameState.hungerMarker && (() => {
                    const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                    const goldenBonus = myPlayer.goldenShells?.length || 0;
                    const handLimit = baseLimit + goldenBonus;
                    const overCount = myPlayer.hand.length - handLimit;
                    return overCount > 0 && (
                      <div className="bg-orange-50 border-2 border-orange-400 rounded-xl p-4 mb-4">
                        <div className="text-center">
                          <h4 className="text-lg font-bold text-orange-900">‚ö†Ô∏è OVERENCUMBERED! ‚ö†Ô∏è</h4>
                          <p className="text-sm text-orange-700 mt-1">
                            You have {myPlayer.hand.length} cards (limit: {handLimit})
                            {goldenBonus > 0 && <span className="block text-xs">(Base: {baseLimit} + {goldenBonus} Golden Shell{goldenBonus > 1 ? 's' : ''})</span>}
                          </p>
                          <p className="text-sm text-orange-700 mb-3">
                            You MUST pay {overCount} energy token{overCount > 1 ? 's' : ''} to continue your turn
                          </p>
                          {myPlayer.energyTokens >= overCount ? (
                            <button 
                              onClick={handleOverencumbered}
                              className="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-xl transition-colors"
                            >
                              üí∞ Pay {overCount} Token{overCount > 1 ? 's' : ''} (Required)
                            </button>
                          ) : (
                            <div>
                              <p className="text-xs text-red-600 mb-2 font-bold">Not enough energy tokens - you will be eliminated!</p>
                              <button 
                                onClick={async () => {
                                  const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                  await database.ref(`games/${roomCode}`).update({
                                    [`players/${playerId}/energyTokens`]: 0,
                                    [`players/${playerId}/eliminated`]: true,
                                    currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length
                                  });
                                }}
                                className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-xl transition-colors"
                              >
                                üíÄ Cannot Pay - Eliminate Me
                              </button>
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  })()}

                  <div className="text-sm text-amber-700 mb-2">
                    Your Hand ({myPlayer.hand?.length || 0} cards) - Limit: {(() => {
                      const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                      const goldenBonus = myPlayer.goldenShells?.length || 0;
                      return baseLimit + goldenBonus;
                    })()}
                  </div>
                  
                  {(!myPlayer.hand || myPlayer.hand.length === 0) ? (
                    <div className="text-center py-8 text-amber-600">
                      {isMyTurn ? 'Draw a card to start your turn!' : 'No cards in hand'}
                    </div>
                  ) : (
                    <>
                      {shellBowlMode && (
                        <div className="mb-3 p-3 bg-amber-100 border-2 border-amber-500 rounded-lg text-center">
                          <p className="text-sm font-bold text-amber-900">
                            ü•ú SHELL BOWL MODE: Select cards to discard ({selectedShellIndices.length} selected)
                          </p>
                          <button
                            onClick={() => {
                              setShellBowlMode(false);
                              setSelectedShellIndices([]);
                              setError('');
                            }}
                            className="mt-2 text-xs bg-gray-400 hover:bg-gray-500 text-white px-3 py-1 rounded"
                          >
                            Cancel
                          </button>
                        </div>
                      )}
                      
                      {multiEatMode && (
                        <div className="mb-3 p-3 bg-green-100 border-2 border-green-500 rounded-lg text-center">
                          <p className="text-sm font-bold text-green-900">
                            üçΩÔ∏è MULTI-EAT MODE: Select 2+ edible cards to eat ({selectedEdibleIndices.length} selected)
                          </p>
                          <p className="text-xs text-green-700 mb-2">Eating 2+ foods gains you 1 energy token!</p>
                          <div className="flex gap-2 justify-center">
                            {selectedEdibleIndices.length >= 2 && (
                              <button
                                onClick={eatMultipleFoods}
                                className="text-xs bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded font-bold"
                              >
                                ‚úì Eat {selectedEdibleIndices.length} Foods (+1 Energy)
                              </button>
                            )}
                            <button
                              onClick={() => {
                                setMultiEatMode(false);
                                setSelectedEdibleIndices([]);
                                setError('');
                              }}
                              className="text-xs bg-gray-400 hover:bg-gray-500 text-white px-3 py-1 rounded"
                            >
                              Cancel
                            </button>
                          </div>
                        </div>
                      )}
                      
                      {selectedCaffeineIndex !== null && (
                        <div className="mb-3 p-3 bg-yellow-100 border-2 border-yellow-500 rounded-lg text-center">
                          <p className="text-sm font-bold text-yellow-900">
                            ‚òï CAFFEINE SELECTED! Click another card to play it caffeinated.
                          </p>
                          <button
                            onClick={() => {
                              setSelectedCaffeineIndex(null);
                              setError('');
                            }}
                            className="mt-2 text-xs bg-gray-400 hover:bg-gray-500 text-white px-3 py-1 rounded"
                          >
                            Cancel
                          </button>
                        </div>
                      )}
                      
                      <div className="flex gap-2 flex-wrap">
                        {myPlayer.hand.map((card, idx) => {
                          const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                          const goldenBonus = myPlayer.goldenShells?.length || 0;
                          const handLimit = baseLimit + goldenBonus;
                          const isOverencumbered = myPlayer.hand.length > handLimit;
                          const canPlayCard = !isOverencumbered || gameState.pendingAction?.type === 'moldy';
                          
                          return (
                            <button
                              key={card.id}
                              onClick={async () => {
                                if (multiEatMode) {
                                  if (selectedEdibleIndices.includes(idx)) {
                                    setSelectedEdibleIndices(selectedEdibleIndices.filter(i => i !== idx));
                                  } else if (['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(card.type)) {
                                    if (card.type === 'pesky' && !myPlayer.tools?.includes('nutcracker')) {
                                      setError('Cannot eat Pesky Pistachio without a Nutcracker!');
                                      return;
                                    }
                                    setSelectedEdibleIndices([...selectedEdibleIndices, idx]);
                                  } else {
                                    setError('Can only select edible cards to eat!');
                                  }
                                } else if (shellBowlMode) {
                                  if (selectedShellIndices.includes(idx)) {
                                    setSelectedShellIndices(selectedShellIndices.filter(i => i !== idx));
                                  } else {
                                    setSelectedShellIndices([...selectedShellIndices, idx]);
                                  }
                                } else if (gameState.pendingAction?.type === 'donate' && gameState.pendingAction.playerId === playerId) {
                                  const selectedIndices = gameState.pendingAction.selectedCardIndices || [];
                                  const cardsNeeded = gameState.pendingAction.cardsToGive;
                                  
                                  if (selectedIndices.includes(idx)) {
                                    await database.ref(`games/${roomCode}/pendingAction/selectedCardIndices`).set(
                                      selectedIndices.filter(i => i !== idx)
                                    );
                                  } else if (selectedIndices.length < cardsNeeded) {
                                    await database.ref(`games/${roomCode}/pendingAction/selectedCardIndices`).set(
                                      [...selectedIndices, idx]
                                    );
                                  } else {
                                    setError(`Already selected ${cardsNeeded} card(s)!`);
                                  }
                                } else if (!canPlayCard) {
                                  setError('You must pay the overencumbered penalty first!');
                                } else {
                                  playCard(idx);
                                }
                              }}
                              onContextMenu={(e) => {
                                e.preventDefault();
                                setZoomedCard({ type: card.type, image: CARD_IMAGES[card.type] });
                              }}
                              className={`w-24 h-32 rounded-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1 transition-all border-2 overflow-hidden disabled:opacity-50 disabled:cursor-not-allowed relative ${
                                multiEatMode && selectedEdibleIndices.includes(idx)
                                  ? 'border-green-500 border-4 ring-2 ring-green-400'
                                  : shellBowlMode && selectedShellIndices.includes(idx)
                                  ? 'border-amber-500 border-4 ring-2 ring-amber-400'
                                  : gameState.pendingAction?.type === 'donate' && gameState.pendingAction.selectedCardIndices?.includes(idx)
                                  ? 'border-blue-500 border-4 ring-2 ring-blue-400' 
                                  : selectedCaffeineIndex === idx
                                  ? 'border-yellow-500 border-4 ring-2 ring-yellow-400'
                                  : 'border-yellow-700'
                              }`}
                              disabled={!isMyTurn}
                            >
                              <img 
                                src={CARD_IMAGES[card.type] || 'images/cards/cardBack.PNG'}
                                alt={card.type}
                                className="w-full h-full object-cover"
                                onError={(e) => {
                                  e.target.style.display = 'none';
                                  e.target.nextSibling.style.display = 'flex';
                                }}
                              />
                              <div 
                                className="absolute inset-0 bg-gradient-to-br from-yellow-400 to-yellow-600 flex items-center justify-center"
                                style={{display: 'none'}}
                              >
                                <div className="text-center px-1">
                                  <div className="font-black text-xs text-yellow-900 break-words">
                                    {card.type.toUpperCase()}
                                  </div>
                                </div>
                              </div>
                            </button>
                          );
                        })}
                      </div>
                    </>
                  )}

                  {gameState.goldenPistachioEvent && 
                    gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
                    !gameState.goldenPistachioEvent.responses?.[playerId] && (
                    <div className="bg-yellow-50 border-2 border-yellow-400 rounded-xl p-4 mb-4 mt-4">
                      <div className="text-center mb-3">
                        <h4 className="text-lg font-bold text-yellow-900">‚ú® GOLDEN PISTACHIO! ‚ú®</h4>
                        <p className="text-sm text-yellow-700 mt-1">
                          {gameState.players[gameState.goldenPistachioEvent.playedBy]?.name} played a Golden Pistachio!
                          <br />You must eat food OR lose 1 energy token.
                        </p>
                      </div>
                      <div className="flex gap-2">
                        <button 
                          onClick={async () => {
                            const newTokens = Math.max(0, myPlayer.energyTokens - 1);
                            const updates = {};
                            updates[`players/${playerId}/energyTokens`] = newTokens;
                            updates[`goldenPistachioEvent/responses/${playerId}`] = 'paid';
                            
                            if (newTokens === 0) {
            const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
            updates[`players/${playerId}/eliminated`] = true;
            
            // Discard tools and golden shells
            const deadPlayerHand = myPlayer.hand || [];
            const deadPlayerTools = myPlayer.tools || [];
            const deadPlayerGoldenShells = myPlayer.goldenShells || [];
            
            const toolsAndShells = [...deadPlayerTools.map(t => ({ type: t, category: 'tool', id: `${t}-discarded` })), 
                                     ...deadPlayerGoldenShells];
            
            // Distribute hand to players counter-clockwise starting from previous player
            const currentIndex = gameState.currentPlayerIndex;
            const previousIndex = (currentIndex - 1 + players.length) % players.length;
            
            let cardIndex = 0;
            for (let i = 0; i < players.length - 1; i++) {
              const playerIndex = (previousIndex - i + players.length) % players.length;
              const targetPlayer = players[playerIndex];
              if (targetPlayer.id !== playerId && cardIndex < deadPlayerHand.length) {
                const cardToGive = deadPlayerHand[cardIndex];
                updates[`players/${targetPlayer.id}/hand`] = [...(targetPlayer.hand || []), cardToGive];
                cardIndex++;
              }
            }
            
            // Rest of hand goes to discard
            const remainingCards = deadPlayerHand.slice(cardIndex);
            updates['discardPile'] = [...(gameState.discardPile || []), ...toolsAndShells, ...remainingCards];
            
            const remainingPlayers = players.filter(p => p.id !== playerId);
            if (remainingPlayers.length === 1) {
              updates['status'] = 'finished';
              updates['winner'] = remainingPlayers[0].id;
              updates['winType'] = 'lastStanding';
            }
          }
                            
                            const responses = {...(gameState.goldenPistachioEvent.responses || {}), [playerId]: 'paid'};
                            const allResponded = gameState.goldenPistachioEvent.playersNeedingResponse.every(pid => responses[pid]);
                            if (allResponded) {
                              updates['goldenPistachioEvent'] = null;
                            }
                            
                            await database.ref(`games/${roomCode}`).update(updates);
                          }}
                          disabled={myPlayer.energyTokens <= 0}
                          className="flex-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                        >
                          üíÄ Lose 1 Token
                        </button>
                        <button 
                          onClick={() => {
                            setError('Click an edible card above to eat it!');
                          }}
                          disabled={!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type))}
                          className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                        >
                          üçΩÔ∏è Eat Food
                        </button>
                      </div>
                      <p className="text-xs text-center text-yellow-600 mt-2">
                        {!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)) 
                          ? "No edible food in hand - must lose token" 
                          : "Click edible cards above to eat"}
                      </p>
                    </div>
                  )}

                  {isMyTurn && (
                    <div className="mt-4 space-y-3">
                      {gameState.pendingAction && gameState.pendingAction.type === 'raccoon' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-gray-50 border-2 border-gray-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-gray-900">ü¶ù RACCOON! ü¶ù</h4>
                            <p className="text-sm text-gray-700 mt-1">
                              Select an opponent to steal {gameState.pendingAction.isCaffeinated ? '2 random cards' : '1 random card'} from!
                            </p>
                          </div>
                          <div className="grid grid-cols-2 gap-2">
                            {Object.values(gameState.players)
                              .filter(p => p.id !== playerId && p.connected && !p.eliminated && p.hand?.length > 0)
                              .map((player) => (
                                <button
                                  key={player.id}
                                  onClick={async () => {
                                    const cardsToSteal = Math.min(
                                      gameState.pendingAction.isCaffeinated ? 2 : 1,
                                      player.hand.length
                                    );
                                    
                                    const victimHand = [...player.hand];
                                    const stolenCards = [];
                                    
                                    for (let i = 0; i < cardsToSteal; i++) {
                                      const randomIndex = Math.floor(Math.random() * victimHand.length);
                                      stolenCards.push(victimHand.splice(randomIndex, 1)[0]);
                                    }
                                    
                                    const myNewHand = [...myPlayer.hand, ...stolenCards];
                                    const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                    
                                    await database.ref(`games/${roomCode}`).update({
                                      [`players/${playerId}/hand`]: myNewHand,
                                      [`players/${player.id}/hand`]: victimHand,
                                      pendingAction: null
                                    });
                                    
                                    setError(`Stole ${cardsToSteal} card(s) from ${player.name}!`);
                                  }}
                                  className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg"
                                >
                                  <div className="flex items-center gap-2 justify-center">
                                    <div 
                                      className="w-4 h-4 rounded-full" 
                                      style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                                    />
                                    <span>{player.name}</span>
                                  </div>
                                  <div className="text-xs mt-1">{player.hand.length} cards</div>
                                </button>
                              ))}
                          </div>
                          {Object.values(gameState.players).filter(p => p.id !== playerId && p.connected && !p.eliminated && p.hand?.length > 0).length === 0 && (
                            <div className="text-center">
                              <p className="text-sm text-gray-600 mb-3">No opponents with cards to steal from!</p>
                              <button
                                onClick={async () => {
                                  await database.ref(`games/${roomCode}/pendingAction`).set(null);
                                }}
                                className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg"
                              >
                                Continue
                              </button>
                            </div>
                          )}
                        </div>
                      )}

                      {gameState.pendingAction && gameState.pendingAction.type === 'donate' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-blue-50 border-2 border-blue-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-blue-900">üéÅ DONATE! üéÅ</h4>
                            <p className="text-sm text-blue-700 mt-1 font-bold">
                              {!gameState.pendingAction.selectedCardIndices || gameState.pendingAction.selectedCardIndices.length < gameState.pendingAction.cardsToGive
                                ? `STEP 1: Select ${gameState.pendingAction.cardsToGive} card(s) to donate (${(gameState.pendingAction.selectedCardIndices || []).length}/${gameState.pendingAction.cardsToGive} selected)`
                                : `STEP 2: Select which player receives the card(s)`}
                            </p>
                          </div>
                          
                          {!gameState.pendingAction.selectedCardIndices || gameState.pendingAction.selectedCardIndices.length < gameState.pendingAction.cardsToGive ? (
                            <p className="text-xs text-center text-blue-600">Click card(s) above to select them</p>
                          ) : (
                            <div className="grid grid-cols-2 gap-2">
                              {Object.values(gameState.players)
                                .filter(p => p.id !== playerId && p.connected && !p.eliminated)
                                .map((player) => (
                                  <button
                                    key={player.id}
                                    onClick={async () => {
                                      const cardIndices = gameState.pendingAction.selectedCardIndices;
                                      const cardsToDonate = cardIndices.map(idx => myPlayer.hand[idx]);
                                      const newMyHand = myPlayer.hand.filter((_, i) => !cardIndices.includes(i));
                                      const newOpponentHand = [...player.hand, ...cardsToDonate];
                                      
                                      await database.ref(`games/${roomCode}`).update({
                                        [`players/${playerId}/hand`]: newMyHand,
                                        [`players/${player.id}/hand`]: newOpponentHand,
                                        pendingAction: null
                                      });
                                      
                                      setError(`Donated ${cardsToDonate.length} card(s) to ${player.name}!`);
                                    }}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg"
                                  >
                                    <div className="flex items-center gap-2 justify-center">
                                      <div 
                                        className="w-6 h-6 rounded-full border-2 border-white" 
                                        style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                                      />
                                      <span>{player.name}</span>
                                    </div>
                                  </button>
                                ))}
                            </div>
                          )}
                        </div>
                      )}

                      {gameState.pendingAction && gameState.pendingAction.type === 'picky' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-purple-50 border-2 border-purple-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-purple-900">üîç PICKY! üîç</h4>
                            <p className="text-sm text-purple-700 mt-1">
                              {gameState.pendingAction.hasGorilla 
                                ? `Pick ${gameState.pendingAction.isCaffeinated ? '2' : '1'} card(s) to keep, then rearrange the top ${gameState.pendingAction.topCards.length} cards`
                                : `Rearrange the top ${gameState.pendingAction.topCards.length} cards of the deck`}
                            </p>
                          </div>
                          
                          {gameState.pendingAction.hasGorilla && (
                            <div className="mb-4">
                              <p className="text-sm font-bold text-purple-900 mb-2">
                                Select {gameState.pendingAction.isCaffeinated ? '2' : '1'} card(s) to keep ({pickySelectedIndices.length} selected):
                              </p>
                              <div className="flex gap-2 justify-center flex-wrap">
                                {pickyReorderedCards.map((card, idx) => (
                                  <button
                                    key={idx}
                                    onClick={() => {
                                      const maxPicks = gameState.pendingAction.isCaffeinated ? 2 : 1;
                                      if (pickySelectedIndices.includes(idx)) {
                                        setPickySelectedIndices(pickySelectedIndices.filter(i => i !== idx));
                                      } else if (pickySelectedIndices.length < maxPicks) {
                                        setPickySelectedIndices([...pickySelectedIndices, idx]);
                                      } else {
                                        setError(`Can only pick ${maxPicks} card(s)!`);
                                      }
                                    }}
                                    className={`px-4 py-2 rounded-lg font-bold ${
                                      pickySelectedIndices.includes(idx)
                                        ? 'bg-purple-600 text-white'
                                        : 'bg-white text-purple-900 border-2 border-purple-300'
                                    }`}
                                  >
                                    {card.type}
                                  </button>
                                ))}
                              </div>
                            </div>
                          )}
                          
                          <div>
                            <p className="text-sm font-bold text-purple-900 mb-2">Deck order (top to bottom):</p>
                            <div className="space-y-2 mb-4">
                              {pickyReorderedCards.map((card, idx) => (
                                <div key={idx} className="flex items-center gap-2 bg-white p-3 rounded-lg border-2 border-purple-300">
                                  <div className="flex-1">
                                    <div className="font-bold text-purple-900">
                                      {idx === 0 ? 'üîù Top' : idx === pickyReorderedCards.length - 1 ? '‚¨áÔ∏è Bottom' : `üìÑ Position ${idx + 1}`}
                                    </div>
                                    <div className="text-sm text-purple-700">{card.type}</div>
                                  </div>
                                  <div className="flex gap-1">
                                    <button
                                      onClick={() => {
                                        if (idx > 0) {
                                          const newOrder = [...pickyReorderedCards];
                                          [newOrder[idx], newOrder[idx - 1]] = [newOrder[idx - 1], newOrder[idx]];
                                          setPickyReorderedCards(newOrder);
                                        }
                                      }}
                                      disabled={idx === 0}
                                      className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 text-white px-3 py-1 rounded disabled:cursor-not-allowed"
                                    >
                                      ‚¨ÜÔ∏è
                                    </button>
                                    <button
                                      onClick={() => {
                                        if (idx < pickyReorderedCards.length - 1) {
                                          const newOrder = [...pickyReorderedCards];
                                          [newOrder[idx], newOrder[idx + 1]] = [newOrder[idx + 1], newOrder[idx]];
                                          setPickyReorderedCards(newOrder);
                                        }
                                      }}
                                      disabled={idx === pickyReorderedCards.length - 1}
                                      className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 text-white px-3 py-1 rounded disabled:cursor-not-allowed"
                                    >
                                      ‚¨áÔ∏è
                                    </button>
                                  </div>
                                </div>
                              ))}
                            </div>
                            
                            <button
                              onClick={async () => {
                                const hasGorilla = gameState.pendingAction.hasGorilla;
                                const maxPicks = gameState.pendingAction.isCaffeinated ? 2 : 1;
                                
                                if (hasGorilla && pickySelectedIndices.length !== maxPicks) {
                                  setError(`Must select exactly ${maxPicks} card(s) to keep!`);
                                  return;
                                }
                                
                                let cardsToAddToHand = [];
                                let cardsToTopDeck = pickyReorderedCards;
                                
                                if (hasGorilla) {
                                  cardsToAddToHand = pickySelectedIndices.map(idx => pickyReorderedCards[idx]);
                                  cardsToTopDeck = pickyReorderedCards.filter((_, idx) => !pickySelectedIndices.includes(idx));
                                }
                                
                                const newDeck = [...gameState.deck];
                                newDeck.splice(0, gameState.pendingAction.topCards.length, ...cardsToTopDeck);
                                
                                const updates = {
                                  deck: newDeck,
                                  pendingAction: null
                                };
                                
                                if (hasGorilla && cardsToAddToHand.length > 0) {
                                  updates[`players/${playerId}/hand`] = [...myPlayer.hand, ...cardsToAddToHand];
                                }
                                
                                await database.ref(`games/${roomCode}`).update(updates);
                                
                                setPickyReorderedCards([]);
                                setPickySelectedIndices([]);
                                setError(hasGorilla ? `Kept ${cardsToAddToHand.length} card(s) and reordered the deck!` : 'Cards reordered on top of deck!');
                              }}
                              disabled={gameState.pendingAction.hasGorilla && pickySelectedIndices.length !== (gameState.pendingAction.isCaffeinated ? 2 : 1)}
                              className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                            >
                              ‚úì Confirm Order
                            </button>
                          </div>
                        </div>
                      )}

                      {gameState.pendingAction && gameState.pendingAction.type === 'moldy' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-green-50 border-2 border-green-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-green-900">ü¶† MOLDY PISTACHIO! ü¶†</h4>
                            <p className="text-sm text-green-700 mt-1">
                              You drew {gameState.pendingAction.count} moldy pistachio{gameState.pendingAction.count > 1 ? 's' : ''}!
                              <br />Discard an edible OR a tool. If you have neither, reveal your hand.
                            </p>
                          </div>
                          <div className="space-y-2">
                            {myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)) ? (
                              <p className="text-xs text-center text-green-700">Click an edible card above to discard it</p>
                            ) : myPlayer.tools && myPlayer.tools.length > 0 ? (
                              <div>
                                <p className="text-xs text-center text-green-700 mb-2">No edibles! Click a tool to discard:</p>
                                <div className="flex gap-2 justify-center">
                                  {myPlayer.tools.map((tool, idx) => (
                                    <button
                                      key={idx}
                                      onClick={async () => {
                                        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                        const newTools = myPlayer.tools.filter((_, i) => i !== idx);
                                        
                                        await database.ref(`games/${roomCode}`).update({
                                          [`players/${playerId}/tools`]: newTools,
                                          currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
                                          pendingAction: null
                                        });
                                      }}
                                      className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm"
                                    >
                                      Discard {tool}
                                    </button>
                                  ))}
                                </div>
                              </div>
                            ) : (
                              <div>
                                <p className="text-sm text-center text-green-700 mb-2 font-bold">No edibles or tools! Your hand will be revealed to other players.</p>
                                <div className="bg-white rounded-lg p-3 mb-3">
                                  <p className="text-xs text-gray-600 mb-2">Your revealed hand:</p>
                                  <div className="flex gap-1 justify-center flex-wrap">
                                    {myPlayer.hand?.map((card, i) => (
                                      <div key={i} className="text-xs bg-gray-100 px-2 py-1 rounded border border-gray-300">
                                        {card.type}
                                      </div>
                                    ))}
                                    {(!myPlayer.hand || myPlayer.hand.length === 0) && (
                                      <div className="text-xs text-gray-500 italic">Empty hand</div>
                                    )}
                                  </div>
                                </div>
                                <button
                                  onClick={async () => {
                                    const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                    
                                    await database.ref(`games/${roomCode}`).update({
                                      revealedHand: {
                                        playerId: playerId,
                                        playerName: myPlayer.name,
                                        cards: myPlayer.hand || [],
                                        timestamp: Date.now()
                                      },
                                      currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
                                      pendingAction: null
                                    });
                                    
                                    setTimeout(async () => {
                                      await database.ref(`games/${roomCode}/revealedHand`).remove();
                                    }, 5000);
                                  }}
                                  className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg"
                                >
                                  Reveal Hand & Continue
                                </button>
                              </div>
                            )}
                          </div>
                        </div>
                      )}

                      {gameState.hungerMarker && !gameState.goldenPistachioEvent && (
                        <div className="bg-red-50 border-2 border-red-400 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-red-900">üî• HUNGER EVENT! üî•</h4>
                            <p className="text-sm text-red-700 mt-1">
                              The previous player ate food. You must eat or pay 1 energy token.
                            </p>
                          </div>
                          <div className="flex gap-2">
                            <button 
                              onClick={async () => {
                                if (myPlayer.energyTokens <= 0) {
                                  setError('No energy tokens left to pay!');
                                  return;
                                }
                                
                                const newTokens = myPlayer.energyTokens - 1;
                                const updates = {
                                  [`players/${playerId}/energyTokens`]: newTokens,
                                  tokenBowl: (gameState.tokenBowl || 0) + 1,
                                  hungerMarker: false
                                };
                                
                                if (newTokens === 0) {
            const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
            updates[`players/${playerId}/eliminated`] = true;
            
            // Discard tools and golden shells
            const deadPlayerHand = myPlayer.hand || [];
            const deadPlayerTools = myPlayer.tools || [];
            const deadPlayerGoldenShells = myPlayer.goldenShells || [];
            
            const toolsAndShells = [...deadPlayerTools.map(t => ({ type: t, category: 'tool', id: `${t}-discarded` })), 
                                     ...deadPlayerGoldenShells];
            
            // Distribute hand to players counter-clockwise starting from previous player
            const currentIndex = gameState.currentPlayerIndex;
            const previousIndex = (currentIndex - 1 + players.length) % players.length;
            
            let cardIndex = 0;
            for (let i = 0; i < players.length - 1; i++) {
              const playerIndex = (previousIndex - i + players.length) % players.length;
              const targetPlayer = players[playerIndex];
              if (targetPlayer.id !== playerId && cardIndex < deadPlayerHand.length) {
                const cardToGive = deadPlayerHand[cardIndex];
                updates[`players/${targetPlayer.id}/hand`] = [...(targetPlayer.hand || []), cardToGive];
                cardIndex++;
              }
            }
            
            // Rest of hand goes to discard
            const remainingCards = deadPlayerHand.slice(cardIndex);
            updates['discardPile'] = [...(gameState.discardPile || []), ...toolsAndShells, ...remainingCards];
            
            const remainingPlayers = players.filter(p => p.id !== playerId);
            if (remainingPlayers.length === 1) {
              updates['status'] = 'finished';
              updates['winner'] = remainingPlayers[0].id;
              updates['winType'] = 'lastStanding';
            }
          }
                                
                                await database.ref(`games/${roomCode}`).update(updates);
                                setError('');
                              }}
                              disabled={myPlayer.energyTokens <= 0}
                              className="flex-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                            >
                              üíÄ Go Hungry (Pay 1 Token)
                            </button>
                            <button 
                              onClick={() => {
                                setError('Click an edible card above to eat it!');
                              }}
                              disabled={!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type))}
                              className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                            >
                              üçΩÔ∏è Eat Food
                            </button>
                          </div>
                          <p className="text-xs text-center text-red-600 mt-2">
                            {!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)) 
                              ? "No edible food in hand" 
                              : "Click food cards above to eat them"}
                          </p>
                        </div>
                      )}

                      {!gameState.hungerMarker && !gameState.goldenPistachioEvent && (() => {
                        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                        const goldenBonus = myPlayer.goldenShells?.length || 0;
                        const handLimit = baseLimit + goldenBonus;
                        const isOverencumbered = myPlayer.hand.length > handLimit;
                        const hasMultipleEdibles = myPlayer.hand?.filter(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)).length >= 2;
                        
                        return (
                          <div className="space-y-2">
                            <div className="flex gap-2">
                              <button 
                                onClick={drawCard}
                                disabled={isOverencumbered}
                                className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                              >
                                üé¥ Draw Card (End Turn)
                              </button>
                              {shellBowlMode ? (
                                <button 
                                  onClick={useShellBowl}
                                  className="px-6 bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 rounded-xl transition-colors"
                                >
                                  ‚úì Confirm Discard
                                </button>
                              ) : (
                                <button 
                                  onClick={useShellBowl}
                                  disabled={(gameState.shellBowl?.length || 0) >= 5 || isOverencumbered}
                                  className="px-6 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                                >
                                  ü•ú Shell Bowl
                                </button>
                              )}
                            </div>
                            {hasMultipleEdibles && !multiEatMode && !shellBowlMode && (
                              <button
                                onClick={() => {
                                  setMultiEatMode(true);
                                  setSelectedEdibleIndices([]);
                                }}
                                disabled={isOverencumbered}
                                className="w-full bg-green-700 hover:bg-green-800 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-2 rounded-xl transition-colors text-sm"
                              >
                                üçΩÔ∏è Eat Multiple Foods (+1 Energy)
                              </button>
                            )}
                          </div>
                        );
                      })()}
                    </div>
                  )}
                </div>
              )}

              <div className="text-center text-white text-sm mt-4">
                ‚úÖ ALL RULES IMPLEMENTED! Picky with Gorilla ‚Ä¢ Fast continues hunger ‚Ä¢ All mechanics verified
              </div>
            </div>
            
            {zoomedCard && (
              <div 
                className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50"
                onClick={() => setZoomedCard(null)}
              >
                <div className="relative">
                  <img 
                    src={zoomedCard.image}
                    alt={zoomedCard.type}
                    className="max-w-md max-h-screen rounded-2xl shadow-2xl border-4 border-yellow-600"
                    onError={(e) => {
                      e.target.style.display = 'none';
                      e.target.nextSibling.style.display = 'flex';
                    }}
                  />
                  <div 
                    className="max-w-md h-96 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-2xl shadow-2xl border-4 border-yellow-600 flex items-center justify-center"
                    style={{display: 'none'}}
                  >
                    <div className="text-center p-8">
                      <div className="text-4xl font-black text-yellow-900 mb-2">
                        {zoomedCard.type.toUpperCase()}
                      </div>
                      <div className="text-sm text-yellow-800">Click anywhere to close</div>
                    </div>
                  </div>
                  <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-75 text-white px-4 py-2 rounded-lg text-sm">
                    Click anywhere to close
                  </div>
                </div>
              </div>
            )}
            
            {showRules && (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                <div className="bg-amber-50 rounded-2xl shadow-2xl max-w-4xl w-full max-h-screen overflow-y-auto border-4 border-amber-900">
                  <div className="sticky top-0 bg-amber-900 text-amber-50 p-4 flex justify-between items-center">
                    <h2 className="text-2xl font-black">üìñ PISTACHIO RULES</h2>
                    <button
                      onClick={() => setShowRules(false)}
                      className="bg-amber-700 hover:bg-amber-600 text-white px-4 py-2 rounded-lg font-bold"
                    >
                      ‚úï Close
                    </button>
                  </div>
                  <div className="p-6 space-y-6">
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üéØ OBJECTIVE</h3>
                      <p className="text-amber-800">Be the first to collect 3 Golden Shells OR be the last player standing!</p>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üéÆ TURN STRUCTURE</h3>
                      <ol className="list-decimal list-inside space-y-2 text-amber-800">
                        <li><strong>Overencumbered Check:</strong> If over hand limit, MUST pay 1 energy token per card over.</li>
                        <li><strong>Hunger Event:</strong> If hunger marker is on deck, must eat food OR pay 1 energy token.</li>
                        <li><strong>Play Cards:</strong> Play as many cards as you want.</li>
                        <li><strong>Shell Bowl:</strong> Pay 1 energy token to discard cards.</li>
                        <li><strong>Draw Card:</strong> Draw 1 card to end turn (2 if you have Gorilla).</li>
                      </ol>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üçΩÔ∏è EATING FOOD</h3>
                      <ul className="list-disc list-inside space-y-1 text-amber-800">
                        <li>Eating 1 food: Places Hunger marker for next player</li>
                        <li>Eating 2+ foods: Gain 1 energy token!</li>
                        <li><strong>Pesky Pistachio:</strong> Requires Nutcracker to eat</li>
                        <li><strong>Golden Pistachio:</strong> Draw a Golden Shell. All other players must eat or lose 1 energy!</li>
                        <li><strong>Raisin:</strong> Gain 1 energy token</li>
                        <li><strong>Loose Pistachio:</strong> Draw 1 extra card when drawn</li>
                      </ul>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üÉè SPECIAL CARDS</h3>
                      <div className="space-y-2 text-amber-800 text-sm">
                        <div><strong>‚òï Caffeinated:</strong> Enhances another card</div>
                        <div><strong>üëã Slap:</strong> Cancel another player's card (4-second window)</div>
                        <div><strong>ü¶ù Raccoon:</strong> Steal 1 random card (2 if caffeinated)</div>
                        <div><strong>üéÅ Donate:</strong> Give 1 card to opponent (2 if caffeinated)</div>
                        <div><strong>üîç Picky:</strong> View top 3 cards and reorder (4 if caffeinated). With Gorilla: Pick 2 cards instead of 1!</div>
                        <div><strong>‚ö° Fast:</strong> Skip turn and continue hunger event (draw cards if caffeinated)</div>
                        <div><strong>üåä Spill Bowl:</strong> Return all energy tokens from shell bowl to players</div>
                        <div><strong>ü¶† Moldy:</strong> Forces you to discard edible/tool or reveal hand</div>
                      </div>
                    </section>
                    
                    <section>
                      <h3 className="text-xl font-bold text-amber-900 mb-2">üí° TIPS</h3>
                      <ul className="list-disc list-inside space-y-1 text-amber-800">
                        <li>Right-click any card in your hand to zoom in</li>
                        <li>Watch for slap windows when opponents play cards</li>
                        <li>Eat multiple foods at once to regain energy</li>
                        <li>Golden Shells increase your hand limit</li>
                      </ul>
                    </section>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      return null;
    }

    ReactDOM.render(<PistachioGame />, document.getElementById('root'));
  </script>
</body>
</html>
