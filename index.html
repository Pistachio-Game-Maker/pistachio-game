<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pistachio - Online Multiplayer Card Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect } = React;

    const firebaseConfig = {
      apiKey: "AIzaSyAP5BJbHJXE2qlxF7xZ3LZU7wUHMiae4Q0",
      authDomain: "pistachio-80ed1.firebaseapp.com",
      databaseURL: "https://pistachio-80ed1-default-rtdb.firebaseio.com",
      projectId: "pistachio-80ed1",
      storageBucket: "pistachio-80ed1.firebasestorage.app",
      messagingSenderId: "1065517356603",
      appId: "1:1065517356603:web:22f17f20546ce44e7fae1e"
    };

    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const database = firebase.database();

    const CARD_IMAGES = {
      pistachio: 'images/cards/pistachio.PNG',
      pesky: 'images/cards/pesky.PNG',
      shell: 'images/cards/shell.PNG',
      loose: 'images/cards/loose.PNG',
      golden: 'images/cards/golden.PNG',
      raisin: 'images/cards/raisin.PNG',
      moldy: 'images/cards/moldy.PNG',
      goldenShell: 'images/cards/goldenShell.PNG',
      nutcracker: 'images/cards/nutcracker.PNG',
      gorilla: 'images/cards/gorilla.PNG',
      slap: 'images/cards/slap.PNG',
      picky: 'images/cards/picky.PNG',
      raccoon: 'images/cards/raccoon.PNG',
      spillBowl: 'images/cards/spillBowl.PNG',
      fast: 'images/cards/fast.PNG',
      caffeinated: 'images/cards/caffeinated.PNG',
      donate: 'images/cards/donate.PNG',
      cardBack: 'images/cards/cardBack.PNG'
    };

    const CARD_DECK = [
      { type: 'pistachio', count: 13, category: 'edible' },
      { type: 'pesky', count: 8, category: 'edible' },
      { type: 'shell', count: 12, category: 'shell' },
      { type: 'loose', count: 4, category: 'edible' },
      { type: 'golden', count: 3, category: 'edible' },
      { type: 'raisin', count: 1, category: 'edible' },
      { type: 'moldy', count: 5, category: 'moldy' },
      { type: 'spillBowl', count: 2, category: 'special' },
      { type: 'fast', count: 5, category: 'special' },
      { type: 'raccoon', count: 5, category: 'special' },
      { type: 'picky', count: 4, category: 'special' },
      { type: 'slap', count: 8, category: 'special' },
      { type: 'caffeinated', count: 6, category: 'special' },
      { type: 'donate', count: 5, category: 'special' },
      { type: 'nutcracker', count: 0, category: 'tool' },
      { type: 'gorilla', count: 0, category: 'tool' }
    ];

    const PLAYER_COLORS = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b'];

    const createDeck = (playerCount) => {
      const deck = [];
      CARD_DECK.forEach(card => {
        let count = card.count;
        if (card.type === 'nutcracker' || card.type === 'gorilla') {
          count = playerCount;
        }
        for (let i = 0; i < count; i++) {
          deck.push({ ...card, id: `${card.type}-${Math.random().toString(36).substr(2, 9)}` });
        }
      });
      return shuffleDeck(deck);
    };

    const shuffleDeck = (deck) => {
      const shuffled = [...deck];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    };

    const generateRoomCode = () => {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    };

    function PistachioGame() {
      const [screen, setScreen] = useState('menu');
      const [roomCode, setRoomCode] = useState('');
      const [joinCode, setJoinCode] = useState('');
      const [playerName, setPlayerName] = useState('');
      const [playerId, setPlayerId] = useState('');
      const [gameState, setGameState] = useState(null);
      const [copied, setCopied] = useState(false);
      const [error, setError] = useState('');
      const [selectedCaffeineIndex, setSelectedCaffeineIndex] = useState(null);
      const [shellBowlMode, setShellBowlMode] = useState(false);
      const [selectedShellIndices, setSelectedShellIndices] = useState([]);
      const [pickyReorderedCards, setPickyReorderedCards] = useState([]);
      const [selectedEdibleIndices, setSelectedEdibleIndices] = useState([]);
      const [multiEatMode, setMultiEatMode] = useState(false);
      const [showSlapWindow, setShowSlapWindow] = useState(false);

      useEffect(() => {
        if (!playerId) {
          setPlayerId(`player-${Date.now()}-${Math.random().toString(36).substring(7)}`);
        }
      }, [playerId]);

      useEffect(() => {
        if (!roomCode) return;

        const gameRef = database.ref(`games/${roomCode}`);
        const listener = gameRef.on('value', (snapshot) => {
          const data = snapshot.val();
          if (data) {
            setGameState(data);
            if (data.status === 'playing' && screen !== 'game') {
              setScreen('game');
            }
            
            // Initialize picky reordered cards when picky action starts
            if (data.pendingAction?.type === 'picky' && data.pendingAction.playerId === playerId && pickyReorderedCards.length === 0) {
              setPickyReorderedCards(data.pendingAction.topCards);
            }
          }
        });

        return () => gameRef.off('value', listener);
      }, [roomCode, screen, playerId, pickyReorderedCards.length]);

      const createGame = async () => {
        if (!playerName.trim()) {
          setError('Please enter your name');
          return;
        }
        
        const code = generateRoomCode();
        const newGame = {
          roomCode: code,
          players: {},
          host: playerId,
          status: 'lobby',
          deck: [],
          goldenDeck: [],
          discardPile: [],
          shellBowl: [],
          hungerMarker: false,
          currentPlayerIndex: 0,
          turnPhase: 'draw',
          createdAt: Date.now()
        };

        newGame.players[playerId] = {
          id: playerId,
          name: playerName,
          hand: [],
          energyTokens: 10,
          colorIndex: 0,
          goldenShells: [],
          tools: [],
          connected: true
        };

        try {
          await database.ref(`games/${code}`).set(newGame);
          setRoomCode(code);
          setScreen('lobby');
          setError('');
        } catch (err) {
          setError('Failed to create game: ' + err.message);
        }
      };

      const joinGame = async () => {
        if (!playerName.trim() || !joinCode.trim()) {
          setError('Please enter your name and room code');
          return;
        }
        
        const code = joinCode.toUpperCase();
        
        try {
          const gameRef = database.ref(`games/${code}`);
          const snapshot = await gameRef.once('value');
          const game = snapshot.val();
          
          if (!game) {
            setError('Game not found');
            return;
          }

          if (game.status !== 'lobby') {
            setError('Game already started');
            return;
          }

          const playerCount = Object.keys(game.players).length;
          if (playerCount >= 4) {
            setError('Game is full');
            return;
          }

          const colorIndex = playerCount;
          const newPlayer = {
            id: playerId,
            name: playerName,
            hand: [],
            energyTokens: 10,
            colorIndex,
            goldenShells: [],
            tools: [],
            connected: true
          };

          await database.ref(`games/${code}/players/${playerId}`).set(newPlayer);
          setRoomCode(code);
          setScreen('lobby');
          setError('');
        } catch (err) {
          setError('Failed to join game: ' + err.message);
        }
      };

      const startGame = async () => {
        if (!gameState) return;
        
        const playerCount = Object.keys(gameState.players).length;
        if (playerCount < 3) {
          setError('Need at least 3 players to start!');
          return;
        }

        const deck = createDeck(playerCount);
        const goldenDeck = [];
        for (let i = 0; i < 9; i++) {
          goldenDeck.push({ type: 'goldenShell', category: 'golden', id: `golden-${i}` });
        }
        const firstPlayerIndex = Math.floor(Math.random() * playerCount);

        try {
          await database.ref(`games/${roomCode}`).update({
            status: 'playing',
            deck,
            goldenDeck: shuffleDeck(goldenDeck),
            currentPlayerIndex: firstPlayerIndex,
            turnPhase: 'draw'
          });
          setError('');
        } catch (err) {
          setError('Failed to start game: ' + err.message);
        }
      };

      const handleOverencumbered = async () => {
        if (!gameState) return;
        
        const myPlayer = gameState.players[playerId];
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        
        if (overCount <= 0) return;
        
        if (myPlayer.energyTokens < overCount) {
          setError(`Need ${overCount} energy tokens but only have ${myPlayer.energyTokens}!`);
          return;
        }
        
        const newTokens = myPlayer.energyTokens - overCount;
        
        const updates = {
          [`players/${playerId}/energyTokens`]: newTokens
        };
        
        if (newTokens === 0) {
          const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
          updates[`players/${playerId}/eliminated`] = true;
          updates['currentPlayerIndex'] = (gameState.currentPlayerIndex + 1) % players.length;
        }
        
        await database.ref(`games/${roomCode}`).update(updates);
        setError('');
      };

      const handleHungerEvent = async (eatFood) => {
        if (!gameState) return;
        
        const myPlayer = gameState.players[playerId];
        
        if (eatFood) {
          setError('Click an edible card from your hand to eat it!');
        } else {
          if (myPlayer.energyTokens <= 0) {
            setError('No energy tokens left to pay!');
            return;
          }
          
          const newTokens = myPlayer.energyTokens - 1;
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/energyTokens`]: newTokens,
            hungerMarker: false
          });
          
          if (newTokens === 0) {
            await database.ref(`games/${roomCode}/players/${playerId}/eliminated`).set(true);
          }
          
          setError('');
        }
      };

      const eatMultipleFoods = async () => {
        if (!gameState || selectedEdibleIndices.length === 0) return;
        
        const myPlayer = gameState.players[playerId];
        const cardsToEat = selectedEdibleIndices.map(idx => myPlayer.hand[idx]);
        const newHand = myPlayer.hand.filter((_, idx) => !selectedEdibleIndices.includes(idx));
        const newDiscard = [...(gameState.discardPile || []), ...cardsToEat];
        
        const updates = {
          [`players/${playerId}/hand`]: newHand,
          discardPile: newDiscard
        };
        
        // If eating 2+ foods, gain 1 energy token
        if (cardsToEat.length >= 2) {
          const newTokens = Math.min(10, myPlayer.energyTokens + 1);
          updates[`players/${playerId}/energyTokens`] = newTokens;
        }
        
        // Check if responding to events
        if (gameState.pendingAction?.type === 'moldy' && gameState.pendingAction.playerId === playerId) {
          const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
          updates['currentPlayerIndex'] = (gameState.currentPlayerIndex + 1) % players.length;
          updates['pendingAction'] = null;
        }
        else if (gameState.goldenPistachioEvent && 
            gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
            !gameState.goldenPistachioEvent.responses?.[playerId]) {
          updates[`goldenPistachioEvent/responses/${playerId}`] = 'ate';
          
          const responses = {...(gameState.goldenPistachioEvent.responses || {}), [playerId]: 'ate'};
          const allResponded = gameState.goldenPistachioEvent.playersNeedingResponse.every(pid => responses[pid]);
          if (allResponded) {
            updates['goldenPistachioEvent'] = null;
          }
        } else if (gameState.hungerMarker) {
          updates['hungerMarker'] = false;
        } else {
          updates['hungerMarker'] = true;
        }
        
        await database.ref(`games/${roomCode}`).update(updates);
        
        setMultiEatMode(false);
        setSelectedEdibleIndices([]);
        if (cardsToEat.length >= 2) {
          setError(`Ate ${cardsToEat.length} foods and gained 1 energy token!`);
        }
      };

      const drawCard = async () => {
        if (!gameState) return;
        
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        const currentPlayer = players[gameState.currentPlayerIndex];
        
        if (currentPlayer.id !== playerId) return;
        
        const myPlayer = gameState.players[playerId];
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        
        if (overCount > 0) {
          setError('You must pay the overencumbered penalty first!');
          return;
        }
        
        if (gameState.goldenPistachioEvent && 
            gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
            !gameState.goldenPistachioEvent.responses?.[playerId]) {
          setError('You must respond to the Golden Pistachio event first!');
          return;
        }
        
        if (gameState.hungerMarker) {
          setError('You must handle the Hunger Event first! Eat food or pay 1 energy token.');
          return;
        }
        
        if (!gameState.deck || gameState.deck.length === 0) {
          setError('Deck is empty!');
          return;
        }

        const cardsToDraw = myPlayer.tools?.includes('gorilla') ? 2 : 1;
        const newDeck = [...gameState.deck];
        const drawnCards = newDeck.splice(0, Math.min(cardsToDraw, newDeck.length));
        
        const moldyCards = drawnCards.filter(card => card.type === 'moldy');
        const nonMoldyCards = drawnCards.filter(card => card.type !== 'moldy');
        
        const newHand = [...(myPlayer.hand || []), ...nonMoldyCards];
        
        if (moldyCards.length > 0) {
          const newDiscard = [...(gameState.discardPile || []), ...moldyCards];
          
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            deck: newDeck,
            discardPile: newDiscard,
            pendingAction: {
              type: 'moldy',
              playerId: playerId,
              count: moldyCards.length
            }
          });
        } else {
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            deck: newDeck,
            currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
            turnPhase: 'draw',
            hungerMarker: false
          });
        }
      };

      const playCard = async (cardIndex) => {
        if (!gameState) return;
        
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        const currentPlayer = players[gameState.currentPlayerIndex];
        if (currentPlayer.id !== playerId) return;

        const myPlayer = gameState.players[playerId];
        
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        if (overCount > 0 && !(gameState.pendingAction?.type === 'moldy')) {
          setError('You must pay the overencumbered penalty first!');
          return;
        }
        
        const card = myPlayer.hand[cardIndex];
        if (!card) return;

        if (card.type === 'caffeinated') {
          setSelectedCaffeineIndex(cardIndex);
          setError('Caffeine selected! Now click another card to play it caffeinated.');
          return;
        }

        const isCaffeinated = selectedCaffeineIndex !== null;
        let newHand = myPlayer.hand.filter((_, i) => i !== cardIndex);
        const cardsToDiscard = [card];
        
        if (isCaffeinated) {
          const caffeineCard = myPlayer.hand[selectedCaffeineIndex];
          newHand = newHand.filter(c => c.id !== caffeineCard.id);
          cardsToDiscard.push(caffeineCard);
          setSelectedCaffeineIndex(null);
        }

        const newDiscard = [...(gameState.discardPile || []), ...cardsToDiscard];

        if (card.type === 'spillBowl') {
          const shellBowl = gameState.shellBowl || [];
          const updates = {};
          
          if (isCaffeinated) {
            shellBowl.forEach(colorIndex => {
              if (colorIndex !== myPlayer.colorIndex) {
                const player = Object.values(gameState.players).find(p => p.colorIndex === colorIndex);
                if (player) {
                  updates[`players/${player.id}/energyTokens`] = Math.min(10, player.energyTokens + 1);
                }
              }
            });
            updates['shellBowl'] = shellBowl.filter(c => c === myPlayer.colorIndex);
          } else {
            shellBowl.forEach(colorIndex => {
              const player = Object.values(gameState.players).find(p => p.colorIndex === colorIndex);
              if (player) {
                updates[`players/${player.id}/energyTokens`] = Math.min(10, player.energyTokens + 1);
              }
            });
            updates['shellBowl'] = [];
          }
          
          updates[`players/${playerId}/hand`] = newHand;
          updates['discardPile'] = newDiscard;
          
          await database.ref(`games/${roomCode}`).update(updates);
          return;
        }

        if (card.type === 'donate') {
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            pendingAction: {
              type: 'donate',
              playerId: playerId,
              cardsToGive: isCaffeinated ? 2 : 1
            }
          });
          return;
        }

        if (card.type === 'fast') {
          const updates = {
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
            turnPhase: 'draw',
            hungerMarker: gameState.hungerMarker
          };
          
          if (isCaffeinated) {
            const cardsToDraw = myPlayer.tools?.includes('gorilla') ? 2 : 1;
            const newDeck = [...gameState.deck];
            const drawnCards = newDeck.splice(0, Math.min(cardsToDraw, newDeck.length));
            const handWithDrawn = [...newHand, ...drawnCards];
            
            updates[`players/${playerId}/hand`] = handWithDrawn;
            updates['deck'] = newDeck;
          }
          
          await database.ref(`games/${roomCode}`).update(updates);
          return;
        }

        if (card.type === 'picky') {
          const topCards = gameState.deck.slice(0, isCaffeinated ? 4 : 3);
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            pendingAction: {
              type: 'picky',
              playerId: playerId,
              topCards: topCards,
              isCaffeinated: isCaffeinated,
              reorderedCards: null
            }
          });
          return;
        }

        if (card.type === 'raccoon') {
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard,
            pendingAction: {
              type: 'raccoon',
              playerId: playerId,
              isCaffeinated: isCaffeinated,
              action: null
            }
          });
          return;
        }

        if (card.category === 'tool') {
          const newTools = [...(myPlayer.tools || []), card.type];
          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            [`players/${playerId}/tools`]: newTools
          });
          return;
        }

        if (card.category === 'edible') {
          // Check if in multi-eat mode
          if (multiEatMode) {
            // Toggle selection
            if (selectedEdibleIndices.includes(cardIndex)) {
              setSelectedEdibleIndices(selectedEdibleIndices.filter(i => i !== cardIndex));
            } else {
              setSelectedEdibleIndices([...selectedEdibleIndices, cardIndex]);
            }
            return;
          }
          
          const updates = {
            [`players/${playerId}/hand`]: newHand,
            discardPile: newDiscard
          };
          
          if (gameState.pendingAction?.type === 'moldy' && gameState.pendingAction.playerId === playerId) {
            const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
            updates['currentPlayerIndex'] = (gameState.currentPlayerIndex + 1) % players.length;
            updates['pendingAction'] = null;
          }
          else if (gameState.goldenPistachioEvent && 
              gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
              !gameState.goldenPistachioEvent.responses?.[playerId]) {
            updates[`goldenPistachioEvent/responses/${playerId}`] = 'ate';
            
            const responses = {...(gameState.goldenPistachioEvent.responses || {}), [playerId]: 'ate'};
            const allResponded = gameState.goldenPistachioEvent.playersNeedingResponse.every(pid => responses[pid]);
            if (allResponded) {
              updates['goldenPistachioEvent'] = null;
            }
          } else if (gameState.hungerMarker) {
            updates['hungerMarker'] = false;
          } else {
            updates['hungerMarker'] = true;
          }
          
          await database.ref(`games/${roomCode}`).update(updates);

          if (card.type === 'golden') {
            const newGoldenDeck = [...(gameState.goldenDeck || [])];
            const goldenShell = newGoldenDeck.shift();
            if (goldenShell) {
              const newGoldenShells = [...(myPlayer.goldenShells || []), goldenShell];
              await database.ref(`games/${roomCode}`).update({
                [`players/${playerId}/goldenShells`]: newGoldenShells,
                goldenDeck: newGoldenDeck
              });

              if (newGoldenShells.length >= 3) {
                await database.ref(`games/${roomCode}`).update({
                  status: 'finished',
                  winner: playerId,
                  winType: 'golden'
                });
                return;
              }
            }

            const otherPlayers = Object.keys(gameState.players).filter(pid => 
              pid !== playerId && 
              gameState.players[pid].connected && 
              !gameState.players[pid].eliminated
            );
            
            if (otherPlayers.length > 0) {
              await database.ref(`games/${roomCode}`).update({
                goldenPistachioEvent: {
                  playedBy: playerId,
                  playersNeedingResponse: otherPlayers,
                  responses: {}
                }
              });
            }
          } else if (card.type === 'raisin') {
            const newTokens = Math.min(10, myPlayer.energyTokens + 1);
            await database.ref(`games/${roomCode}/players/${playerId}/energyTokens`).set(newTokens);
          }
          return;
        }

        await database.ref(`games/${roomCode}`).update({
          [`players/${playerId}/hand`]: newHand,
          discardPile: newDiscard
        });
      };

      const useShellBowl = async () => {
        if (!gameState) return;
        
        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
        const currentPlayer = players[gameState.currentPlayerIndex];
        if (currentPlayer.id !== playerId) return;

        const myPlayer = gameState.players[playerId];
        
        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
        const goldenBonus = myPlayer.goldenShells?.length || 0;
        const handLimit = baseLimit + goldenBonus;
        const overCount = myPlayer.hand.length - handLimit;
        if (overCount > 0) {
          setError('You must pay the overencumbered penalty first!');
          return;
        }
        
        if (!shellBowlMode) {
          if (myPlayer.energyTokens <= 0) {
            setError('No energy tokens left!');
            return;
          }
          if ((gameState.shellBowl || []).length >= 5) {
            setError('Shell bowl is full!');
            return;
          }
          
          setShellBowlMode(true);
          setSelectedShellIndices([]);
          setError('Select cards to discard, then click "Confirm Discard"');
          return;
        } else {
          if (selectedShellIndices.length === 0) {
            setError('Select at least one card to discard!');
            return;
          }
          
          const cardsToDiscard = selectedShellIndices.map(idx => myPlayer.hand[idx]);
          const newHand = myPlayer.hand.filter((_, idx) => !selectedShellIndices.includes(idx));
          const newShellBowl = [...(gameState.shellBowl || []), myPlayer.colorIndex];
          const newTokens = myPlayer.energyTokens - 1;

          await database.ref(`games/${roomCode}`).update({
            [`players/${playerId}/hand`]: newHand,
            [`players/${playerId}/energyTokens`]: newTokens,
            shellBowl: newShellBowl,
            discardPile: [...(gameState.discardPile || []), ...cardsToDiscard]
          });

          if (newTokens === 0) {
            await database.ref(`games/${roomCode}/players/${playerId}/eliminated`).set(true);
          }
          
          setShellBowlMode(false);
          setSelectedShellIndices([]);
          setError('');
        }
      };

      const leaveGame = async () => {
        if (roomCode && playerId) {
          await database.ref(`games/${roomCode}/players/${playerId}/connected`).set(false);
        }
        setScreen('menu');
        setRoomCode('');
        setGameState(null);
      };

      const copyRoomCode = () => {
        navigator.clipboard.writeText(roomCode);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      };

      if (screen === 'menu') {
        return (
          <div className="min-h-screen bg-gradient-to-br from-amber-900 via-yellow-800 to-amber-900 flex items-center justify-center p-4">
            <div className="bg-amber-50 rounded-3xl shadow-2xl p-8 max-w-md w-full border-4 border-amber-900">
              <div className="text-center mb-8">
                <h1 className="text-5xl font-black text-amber-900 mb-2">PISTACHIO</h1>
                <p className="text-amber-700 font-medium">Online Multiplayer Card Game</p>
              </div>

              {error && (
                <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl mb-4 text-sm">
                  {error}
                </div>
              )}

              <div className="space-y-4 mb-6">
                <input
                  type="text"
                  placeholder="Enter your name"
                  value={playerName}
                  onChange={(e) => setPlayerName(e.target.value)}
                  className="w-full px-4 py-3 rounded-xl border-2 border-amber-300 focus:border-amber-500 focus:outline-none text-lg"
                  maxLength={20}
                />
              </div>

              <div className="space-y-3">
                <button
                  onClick={createGame}
                  disabled={!playerName.trim()}
                  className="w-full bg-amber-600 hover:bg-amber-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-bold py-4 rounded-xl transition-colors text-lg"
                >
                  üë• Create Game
                </button>

                <div className="relative">
                  <div className="absolute inset-0 flex items-center">
                    <div className="w-full border-t border-amber-300"></div>
                  </div>
                  <div className="relative flex justify-center text-sm">
                    <span className="px-2 bg-amber-50 text-amber-600 font-medium">OR</span>
                  </div>
                </div>

                <input
                  type="text"
                  placeholder="Enter room code"
                  value={joinCode}
                  onChange={(e) => setJoinCode(e.target.value.toUpperCase())}
                  className="w-full px-4 py-3 rounded-xl border-2 border-amber-300 focus:border-amber-500 focus:outline-none text-lg text-center font-bold uppercase"
                  maxLength={6}
                />

                <button
                  onClick={joinGame}
                  disabled={!playerName.trim() || !joinCode.trim()}
                  className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white font-bold py-4 rounded-xl transition-colors text-lg"
                >
                  ‚ñ∂Ô∏è Join Game
                </button>
              </div>
            </div>
          </div>
        );
      }

      if (screen === 'lobby' && gameState) {
        const players = Object.values(gameState.players).filter(p => p.connected);
        
        return (
          <div className="min-h-screen bg-gradient-to-br from-amber-900 via-yellow-800 to-amber-900 flex items-center justify-center p-4">
            <div className="bg-amber-50 rounded-3xl shadow-2xl p-8 max-w-2xl w-full border-4 border-amber-900">
              <div className="flex justify-between items-start mb-6">
                <div className="text-center flex-1">
                  <h2 className="text-3xl font-black text-amber-900 mb-2">Game Lobby</h2>
                  <div className="flex items-center justify-center gap-2 mb-4">
                    <div className="bg-amber-900 text-amber-50 px-6 py-2 rounded-xl text-2xl font-black tracking-wider">
                      {roomCode}
                    </div>
                    <button
                      onClick={copyRoomCode}
                      className="p-2 bg-amber-600 hover:bg-amber-700 text-white rounded-lg transition-colors"
                    >
                      {copied ? '‚úì' : 'üìã'}
                    </button>
                  </div>
                  <p className="text-amber-700">Share this code with your friends!</p>
                </div>
                <button
                  onClick={leaveGame}
                  className="p-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
                >
                  üö™
                </button>
              </div>

              {error && (
                <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl mb-4 text-sm">
                  {error}
                </div>
              )}

              <div className="bg-white rounded-xl p-6 mb-6">
                <h3 className="font-bold text-xl text-amber-900 mb-4">Players ({players.length}/4)</h3>
                <div className="space-y-2">
                  {players.map((player) => (
                    <div key={player.id} className="flex items-center gap-3 p-3 bg-amber-50 rounded-lg">
                      <div 
                        className="w-8 h-8 rounded-full" 
                        style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                      />
                      <span className="font-bold text-lg">{player.name}</span>
                      {player.id === gameState.host && (
                        <span className="ml-auto bg-amber-600 text-white px-2 py-1 rounded text-xs font-bold">
                          HOST
                        </span>
                      )}
                    </div>
                  ))}
                </div>
              </div>

              {playerId === gameState.host && (
                <button
                  onClick={startGame}
                  disabled={players.length < 3}
                  className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-4 rounded-xl transition-colors text-lg"
                >
                  {players.length < 3 
                    ? `Need ${3 - players.length} more player(s)` 
                    : 'üéÆ Start Game'}
                </button>
              )}

              {playerId !== gameState.host && (
                <div className="text-center text-amber-700 font-medium">
                  Waiting for host to start the game...
                </div>
              )}
            </div>
          </div>
        );
      }

      if (screen === 'game' && gameState) {
        const players = gameState.players ? Object.values(gameState.players).filter(p => p.connected && !p.eliminated) : [];
        const currentPlayer = players.length > 0 ? players[gameState.currentPlayerIndex] : null;
        const myPlayer = gameState.players ? gameState.players[playerId] : null;
        const isMyTurn = currentPlayer?.id === playerId;

        if (gameState.status === 'finished') {
          const winner = gameState.players[gameState.winner];
          return (
            <div className="min-h-screen bg-gradient-to-br from-yellow-400 via-yellow-500 to-yellow-600 flex items-center justify-center p-4">
              <div className="bg-white rounded-3xl shadow-2xl p-12 max-w-2xl w-full border-4 border-yellow-700 text-center">
                <h1 className="text-6xl font-black text-yellow-900 mb-4">üéâ GAME OVER! üéâ</h1>
                <h2 className="text-4xl font-bold text-yellow-800 mb-8">{winner?.name} WINS!</h2>
                <p className="text-xl text-gray-700 mb-8">
                  {gameState.winType === 'golden' ? 'Collected 3 Golden Shells!' : 'Last Player Standing!'}
                </p>
                <button
                  onClick={() => {
                    setScreen('menu');
                    setRoomCode('');
                    setGameState(null);
                  }}
                  className="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-4 px-8 rounded-xl text-lg"
                >
                  Back to Menu
                </button>
              </div>
            </div>
          );
        }

        if (!myPlayer) {
          return (
            <div className="min-h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-green-900 p-4 flex items-center justify-center">
              <div className="text-white text-center">
                <h1 className="text-4xl font-bold mb-4">Loading...</h1>
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-gradient-to-br from-green-900 via-emerald-800 to-green-900 p-4">
            <div className="max-w-7xl mx-auto">
              <div className="bg-amber-50 rounded-2xl shadow-lg p-4 mb-4 border-2 border-amber-900">
                <div className="flex justify-between items-center">
                  <div>
                    <h1 className="text-2xl font-black text-amber-900">PISTACHIO</h1>
                    <p className="text-sm text-amber-700">Room: {roomCode}</p>
                  </div>
                  <div className="text-center flex-1">
                    <div className="text-lg font-bold text-amber-900">
                      {isMyTurn ? "üî• YOUR TURN üî•" : `${currentPlayer?.name}'s Turn`}
                    </div>
                  </div>
                  <button
                    onClick={leaveGame}
                    className="p-2 bg-red-600 hover:bg-red-700 text-white rounded-lg transition-colors"
                  >
                    üö™
                  </button>
                </div>
              </div>

              {error && (
                <div className="bg-red-100 border-2 border-red-400 text-red-700 px-4 py-3 rounded-xl mb-4 text-sm">
                  {error}
                </div>
              )}

              {gameState.revealedHand && (
                <div className="bg-purple-50 border-2 border-purple-400 rounded-xl p-4 mb-4">
                  <div className="text-center">
                    <h4 className="text-lg font-bold text-purple-900">üëÅÔ∏è HAND REVEALED! üëÅÔ∏è</h4>
                    <p className="text-sm text-purple-700 mb-2">
                      {gameState.revealedHand.playerName} had no edibles or tools for the Moldy Pistachio!
                    </p>
                    <div className="flex gap-2 justify-center flex-wrap">
                      {gameState.revealedHand.cards.map((card, i) => (
                        <div key={i} className="bg-white px-3 py-1 rounded border-2 border-purple-300 text-sm font-bold">
                          {card.type}
                        </div>
                      ))}
                      {gameState.revealedHand.cards.length === 0 && (
                        <div className="text-sm text-purple-600 italic">Empty hand</div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              <div className="grid grid-cols-3 gap-4 mb-4">
                <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                  <h3 className="font-bold text-amber-900 mb-2">Main Deck</h3>
                  <div className="relative">
                    <div className="w-32 h-44 bg-gradient-to-br from-amber-700 to-amber-900 rounded-lg shadow-lg flex items-center justify-center border-4 border-amber-950 overflow-hidden">
                      <img 
                        src="images/cards/cardBack.PNG" 
                        alt="Card Back" 
                        className="w-full h-full object-cover"
                        onError={(e) => {
                          e.target.style.display = 'none';
                          e.target.nextSibling.style.display = 'flex';
                        }}
                      />
                      <div className="text-white font-black text-4xl absolute" style={{display: 'none'}}>
                        {gameState.deck?.length || 0}
                      </div>
                    </div>
                    <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-sm font-bold">
                      {gameState.deck?.length || 0}
                    </div>
                    {gameState.hungerMarker && (
                      <div className="absolute -top-2 -right-2 bg-red-600 text-white px-3 py-1 rounded-full text-xs font-bold animate-pulse">
                        HUNGER
                      </div>
                    )}
                  </div>
                </div>

                <div className="space-y-4">
                  <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                    <h3 className="font-bold text-amber-900 mb-2">Discard</h3>
                    <div className="w-32 h-44 bg-gray-300 rounded-lg shadow-lg flex items-center justify-center border-2 border-gray-400 overflow-hidden">
                      {gameState.discardPile?.length > 0 ? (
                        <img 
                          src={CARD_IMAGES[gameState.discardPile[gameState.discardPile.length - 1].type] || 'images/cards/cardBack.PNG'}
                          alt={gameState.discardPile[gameState.discardPile.length - 1].type}
                          className="w-full h-full object-cover"
                          onError={(e) => {
                            e.target.style.display = 'none';
                            e.target.nextSibling.style.display = 'block';
                          }}
                        />
                      ) : null}
                      <div className="text-gray-500 text-sm" style={{display: gameState.discardPile?.length > 0 ? 'none' : 'block'}}>
                        Empty
                      </div>
                    </div>
                  </div>

                  <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                    <h3 className="font-bold text-amber-900 mb-2">Shell Bowl</h3>
                    <div className="flex gap-1">
                      {[0,1,2,3,4].map(i => (
                        <div 
                          key={i}
                          className="w-6 h-6 rounded-full border-2"
                          style={
                            i < (gameState.shellBowl?.length || 0)
                              ? { backgroundColor: PLAYER_COLORS[gameState.shellBowl[i]], borderColor: '#78350f' }
                              : { backgroundColor: 'white', borderColor: '#fbbf24' }
                          }
                        />
                      ))}
                    </div>
                    <div className="text-xs text-amber-700 mt-1">{gameState.shellBowl?.length || 0}/5</div>
                  </div>
                </div>

                <div className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                  <h3 className="font-bold text-amber-900 mb-2">Golden Shells</h3>
                  <div className="relative">
                    <div className="w-32 h-44 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-lg shadow-lg flex items-center justify-center border-4 border-yellow-700 overflow-hidden">
                      <img 
                        src="images/cards/goldenShell.PNG" 
                        alt="Golden Shell" 
                        className="w-full h-full object-cover"
                        onError={(e) => {
                          e.target.style.display = 'none';
                          e.target.nextSibling.style.display = 'flex';
                        }}
                      />
                      <div className="text-yellow-900 font-black text-4xl absolute" style={{display: 'none'}}>
                        {gameState.goldenDeck?.length || 0}
                      </div>
                    </div>
                    <div className="absolute bottom-2 right-2 bg-black bg-opacity-75 text-white px-2 py-1 rounded text-sm font-bold">
                      {gameState.goldenDeck?.length || 0}
                    </div>
                  </div>
                </div>
              </div>

              <div className="grid grid-cols-3 gap-4 mb-4">
                {players && players.filter(p => p.id !== playerId).map((player) => (
                  <div key={player.id} className="bg-amber-50 rounded-xl p-4 border-2 border-amber-900">
                    <div className="flex items-center gap-2 mb-2">
                      <div 
                        className="w-6 h-6 rounded-full" 
                        style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                      />
                      <h3 className="font-bold text-amber-900">{player.name}</h3>
                    </div>
                    <div className="text-sm space-y-1">
                      <div>‚ö° Energy: {player.energyTokens}/10</div>
                      <div>üÉè Cards: {player.hand?.length || 0}</div>
                      <div>‚ú® Golden: {player.goldenShells?.length || 0}</div>
                      {player.tools && player.tools.length > 0 && (
                        <div className="flex gap-1 mt-2 flex-wrap">
                          {player.tools.map((tool, i) => (
                            <div key={i} className="text-xs bg-amber-200 px-2 py-1 rounded">
                              {tool}
                            </div>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>

              {myPlayer && (
                <div className="bg-amber-50 rounded-2xl p-6 border-4 border-amber-900">
                  <div className="flex justify-between items-center mb-4">
                    <div className="flex items-center gap-3">
                      <div 
                        className="w-8 h-8 rounded-full" 
                        style={{ backgroundColor: PLAYER_COLORS[myPlayer.colorIndex] }}
                      />
                      <h3 className="font-bold text-xl text-amber-900">{myPlayer.name} (You)</h3>
                    </div>
                    <div className="flex items-center gap-4">
                      <div className="text-right">
                        <div className="text-sm text-amber-700">Energy</div>
                        <div className="text-2xl font-black text-amber-900">{myPlayer.energyTokens}/10</div>
                      </div>
                      {myPlayer.goldenShells && myPlayer.goldenShells.length > 0 && (
                        <div className="text-right">
                          <div className="text-sm text-amber-700">Golden Shells</div>
                          <div className="text-2xl font-black text-yellow-600">{myPlayer.goldenShells.length}/3</div>
                        </div>
                      )}
                    </div>
                  </div>

                  {myPlayer.goldenShells && myPlayer.goldenShells.length > 0 && (
                    <div className="mb-4">
                      <div className="text-sm text-amber-700 mb-2">Your Golden Shells:</div>
                      <div className="flex gap-2">
                        {myPlayer.goldenShells.map((shell, i) => (
                          <div key={i} className="w-16 h-20 rounded-lg overflow-hidden border-2 border-yellow-600 shadow-lg">
                            <img 
                              src="images/cards/goldenShell.PNG" 
                              alt="Golden Shell" 
                              className="w-full h-full object-cover"
                            />
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {myPlayer.tools && myPlayer.tools.length > 0 && (
                    <div className="mb-4">
                      <div className="text-sm text-amber-700 mb-2">Tools in Play:</div>
                      <div className="flex gap-2">
                        {myPlayer.tools.map((tool, i) => (
                          <div key={i} className="w-16 h-20 rounded-lg overflow-hidden border-2 border-amber-600 shadow-lg">
                            <img 
                              src={CARD_IMAGES[tool]}
                              alt={tool}
                              className="w-full h-full object-cover"
                            />
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {isMyTurn && myPlayer.hand && !gameState.pendingAction && !gameState.goldenPistachioEvent && !gameState.hungerMarker && (() => {
                    const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                    const goldenBonus = myPlayer.goldenShells?.length || 0;
                    const handLimit = baseLimit + goldenBonus;
                    const overCount = myPlayer.hand.length - handLimit;
                    return overCount > 0 && (
                      <div className="bg-orange-50 border-2 border-orange-400 rounded-xl p-4 mb-4">
                        <div className="text-center">
                          <h4 className="text-lg font-bold text-orange-900">‚ö†Ô∏è OVERENCUMBERED! ‚ö†Ô∏è</h4>
                          <p className="text-sm text-orange-700 mt-1">
                            You have {myPlayer.hand.length} cards (limit: {handLimit})
                            {goldenBonus > 0 && <span className="block text-xs">(Base: {baseLimit} + {goldenBonus} Golden Shell{goldenBonus > 1 ? 's' : ''})</span>}
                          </p>
                          <p className="text-sm text-orange-700 mb-3">
                            You MUST pay {overCount} energy token{overCount > 1 ? 's' : ''} to continue your turn
                          </p>
                          {myPlayer.energyTokens >= overCount ? (
                            <button 
                              onClick={handleOverencumbered}
                              className="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-xl transition-colors"
                            >
                              üí∞ Pay {overCount} Token{overCount > 1 ? 's' : ''} (Required)
                            </button>
                          ) : (
                            <div>
                              <p className="text-sm text-green-700 mt-1">
                              You drew {gameState.pendingAction.count} moldy pistachio{gameState.pendingAction.count > 1 ? 's' : ''}!
                              <br />Discard an edible OR a tool. If you have neither, reveal your hand.
                            </p>
                          </div>
                          <div className="space-y-2">
                            {myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)) ? (
                              <p className="text-xs text-center text-green-700">Click an edible card above to discard it</p>
                            ) : myPlayer.tools && myPlayer.tools.length > 0 ? (
                              <div>
                                <p className="text-xs text-center text-green-700 mb-2">No edibles! Click a tool to discard:</p>
                                <div className="flex gap-2 justify-center">
                                  {myPlayer.tools.map((tool, idx) => (
                                    <button
                                      key={idx}
                                      onClick={async () => {
                                        const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                        const newTools = myPlayer.tools.filter((_, i) => i !== idx);
                                        
                                        await database.ref(`games/${roomCode}`).update({
                                          [`players/${playerId}/tools`]: newTools,
                                          currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
                                          pendingAction: null
                                        });
                                      }}
                                      className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-sm"
                                    >
                                      Discard {tool}
                                    </button>
                                  ))}
                                </div>
                              </div>
                            ) : (
                              <div>
                                <p className="text-sm text-center text-green-700 mb-2 font-bold">No edibles or tools! Your hand will be revealed to other players.</p>
                                <div className="bg-white rounded-lg p-3 mb-3">
                                  <p className="text-xs text-gray-600 mb-2">Your revealed hand:</p>
                                  <div className="flex gap-1 justify-center flex-wrap">
                                    {myPlayer.hand?.map((card, i) => (
                                      <div key={i} className="text-xs bg-gray-100 px-2 py-1 rounded border border-gray-300">
                                        {card.type}
                                      </div>
                                    ))}
                                    {(!myPlayer.hand || myPlayer.hand.length === 0) && (
                                      <div className="text-xs text-gray-500 italic">Empty hand</div>
                                    )}
                                  </div>
                                </div>
                                <button
                                  onClick={async () => {
                                    const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                    
                                    await database.ref(`games/${roomCode}`).update({
                                      revealedHand: {
                                        playerId: playerId,
                                        playerName: myPlayer.name,
                                        cards: myPlayer.hand || [],
                                        timestamp: Date.now()
                                      },
                                      currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length,
                                      pendingAction: null
                                    });
                                    
                                    setTimeout(async () => {
                                      await database.ref(`games/${roomCode}/revealedHand`).remove();
                                    }, 5000);
                                  }}
                                  className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg"
                                >
                                  Reveal Hand & Continue
                                </button>
                              </div>
                            )}
                          </div>
                        </div>
                      )}

                      {gameState.hungerMarker && !gameState.goldenPistachioEvent && (
                        <div className="bg-red-50 border-2 border-red-400 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-red-900">üî• HUNGER EVENT! üî•</h4>
                            <p className="text-sm text-red-700 mt-1">
                              The previous player ate food. You must eat or pay 1 energy token.
                            </p>
                          </div>
                          <div className="flex gap-2">
                            <button 
                              onClick={() => handleHungerEvent(false)}
                              disabled={myPlayer.energyTokens <= 0}
                              className="flex-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                            >
                              üíÄ Go Hungry (Pay 1 Token)
                            </button>
                            <button 
                              onClick={() => handleHungerEvent(true)}
                              disabled={!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type))}
                              className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                            >
                              üçΩÔ∏è Eat Food
                            </button>
                          </div>
                          <p className="text-xs text-center text-red-600 mt-2">
                            {!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)) 
                              ? "No edible food in hand" 
                              : "Click food cards above to eat them"}
                          </p>
                        </div>
                      )}

                      {!gameState.hungerMarker && !gameState.goldenPistachioEvent && (() => {
                        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                        const goldenBonus = myPlayer.goldenShells?.length || 0;
                        const handLimit = baseLimit + goldenBonus;
                        const isOverencumbered = myPlayer.hand.length > handLimit;
                        const hasMultipleEdibles = myPlayer.hand?.filter(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)).length >= 2;
                        
                        return (
                          <div className="space-y-2">
                            <div className="flex gap-2">
                              <button 
                                onClick={drawCard}
                                disabled={isOverencumbered}
                                className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                              >
                                üé¥ Draw Card (End Turn)
                              </button>
                              {shellBowlMode ? (
                                <button 
                                  onClick={useShellBowl}
                                  className="px-6 bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 rounded-xl transition-colors"
                                >
                                  ‚úì Confirm Discard
                                </button>
                              ) : (
                                <button 
                                  onClick={useShellBowl}
                                  disabled={(gameState.shellBowl?.length || 0) >= 5 || isOverencumbered}
                                  className="px-6 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                                >
                                  ü•ú Shell Bowl
                                </button>
                              )}
                            </div>
                            {hasMultipleEdibles && !multiEatMode && !shellBowlMode && (
                              <button
                                onClick={() => {
                                  setMultiEatMode(true);
                                  setSelectedEdibleIndices([]);
                                }}
                                disabled={isOverencumbered}
                                className="w-full bg-green-700 hover:bg-green-800 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-2 rounded-xl transition-colors text-sm"
                              >
                                üçΩÔ∏è Eat Multiple Foods (+1 Energy)
                              </button>
                            )}
                          </div>
                        );
                      })()} transition-colors"
                            >
                              üé¥ Draw Card (End Turn)
                            </button>
                            {shellBowlMode ? (
                              <button 
                                onClick={useShellBowl}
                                className="px-6 bg-amber-600 hover:bg-amber-700 text-white font-bold py-3 rounded-xl transition-colors"
                              >
                                ‚úì Confirm Discard
                              </button>
                            ) : (
                              <button 
                                onClick={useShellBowl}
                                disabled={(gameState.shellBowl?.length || 0) >= 5 || isOverencumbered}
                                className="px-6 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                              >
                                ü•ú Shell Bowl
                              </button>
                            )}
                          </div>
                        );
                      })()}
                    </div>
                  )}
                </div>
              )}

              <div className="text-center text-white text-sm mt-4">
                Groups 1-3 Fixes: Overencumbered, Moldy, Raccoon, Donate, Picky, Multi-Eat, Golden Shells Hand Limit, Fast+Caffeine
              </div>
            </div>
          </div>
        );
      }

      return null;
    }

    ReactDOM.render(<PistachioGame />, document.getElementById('root'));
  </script>
</body>
</html>-xs text-red-600 mb-2 font-bold">Not enough energy tokens - you will be eliminated!</p>
                              <button 
                                onClick={async () => {
                                  const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                  await database.ref(`games/${roomCode}`).update({
                                    [`players/${playerId}/energyTokens`]: 0,
                                    [`players/${playerId}/eliminated`]: true,
                                    currentPlayerIndex: (gameState.currentPlayerIndex + 1) % players.length
                                  });
                                }}
                                className="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-xl transition-colors"
                              >
                                üíÄ Cannot Pay - Eliminate Me
                              </button>
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  })()}

                  <div className="text-sm text-amber-700 mb-2">
                    Your Hand ({myPlayer.hand?.length || 0} cards) - Limit: {(() => {
                      const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                      const goldenBonus = myPlayer.goldenShells?.length || 0;
                      return baseLimit + goldenBonus;
                    })()}
                  </div>
                  
                  {(!myPlayer.hand || myPlayer.hand.length === 0) ? (
                    <div className="text-center py-8 text-amber-600">
                      {isMyTurn ? 'Draw a card to start your turn!' : 'No cards in hand'}
                    </div>
                  ) : (
                    <>
                      {shellBowlMode && (
                        <div className="mb-3 p-3 bg-amber-100 border-2 border-amber-500 rounded-lg text-center">
                          <p className="text-sm font-bold text-amber-900">
                            ü•ú SHELL BOWL MODE: Select cards to discard ({selectedShellIndices.length} selected)
                          </p>
                          <button
                            onClick={() => {
                              setShellBowlMode(false);
                              setSelectedShellIndices([]);
                              setError('');
                            }}
                            className="mt-2 text-xs bg-gray-400 hover:bg-gray-500 text-white px-3 py-1 rounded"
                          >
                            Cancel
                          </button>
                        </div>
                      )}
                      
                      {multiEatMode && (
                        <div className="mb-3 p-3 bg-green-100 border-2 border-green-500 rounded-lg text-center">
                          <p className="text-sm font-bold text-green-900">
                            üçΩÔ∏è MULTI-EAT MODE: Select 2+ edible cards to eat ({selectedEdibleIndices.length} selected)
                          </p>
                          <p className="text-xs text-green-700 mb-2">Eating 2+ foods gains you 1 energy token!</p>
                          <div className="flex gap-2 justify-center">
                            {selectedEdibleIndices.length >= 2 && (
                              <button
                                onClick={eatMultipleFoods}
                                className="text-xs bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded font-bold"
                              >
                                ‚úì Eat {selectedEdibleIndices.length} Foods (+1 Energy)
                              </button>
                            )}
                            <button
                              onClick={() => {
                                setMultiEatMode(false);
                                setSelectedEdibleIndices([]);
                                setError('');
                              }}
                              className="text-xs bg-gray-400 hover:bg-gray-500 text-white px-3 py-1 rounded"
                            >
                              Cancel
                            </button>
                          </div>
                        </div>
                      )}
                      
                      {selectedCaffeineIndex !== null && (
                        <div className="mb-3 p-3 bg-yellow-100 border-2 border-yellow-500 rounded-lg text-center">
                          <p className="text-sm font-bold text-yellow-900">
                            ‚òï CAFFEINE SELECTED! Click another card to play it caffeinated.
                          </p>
                          <button
                            onClick={() => {
                              setSelectedCaffeineIndex(null);
                              setError('');
                            }}
                            className="mt-2 text-xs bg-gray-400 hover:bg-gray-500 text-white px-3 py-1 rounded"
                          >
                            Cancel
                          </button>
                        </div>
                      )}
                      
                      <div className="flex gap-2 flex-wrap">
                      {myPlayer.hand.map((card, idx) => {
                        const baseLimit = myPlayer.tools?.includes('gorilla') ? 7 : 5;
                        const goldenBonus = myPlayer.goldenShells?.length || 0;
                        const handLimit = baseLimit + goldenBonus;
                        const isOverencumbered = myPlayer.hand.length > handLimit;
                        const canPlayCard = !isOverencumbered || gameState.pendingAction?.type === 'moldy';
                        
                        return (
                          <button
                            key={card.id}
                            onClick={async () => {
                              if (multiEatMode) {
                                // Toggle selection for multi-eat
                                if (selectedEdibleIndices.includes(idx)) {
                                  setSelectedEdibleIndices(selectedEdibleIndices.filter(i => i !== idx));
                                } else if (['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(card.type)) {
                                  setSelectedEdibleIndices([...selectedEdibleIndices, idx]);
                                } else {
                                  setError('Can only select edible cards to eat!');
                                }
                              } else if (shellBowlMode) {
                                if (selectedShellIndices.includes(idx)) {
                                  setSelectedShellIndices(selectedShellIndices.filter(i => i !== idx));
                                } else {
                                  setSelectedShellIndices([...selectedShellIndices, idx]);
                                }
                              } else if (gameState.pendingAction?.type === 'donate' && gameState.pendingAction.playerId === playerId) {
                                await database.ref(`games/${roomCode}/pendingAction/selectedCardIndex`).set(idx);
                              } else if (!canPlayCard) {
                                setError('You must pay the overencumbered penalty first!');
                              } else {
                                playCard(idx);
                              }
                            }}
                            className={`w-24 h-32 rounded-lg shadow-lg hover:shadow-xl transform hover:-translate-y-1 transition-all border-2 overflow-hidden disabled:opacity-50 disabled:cursor-not-allowed relative ${
                              multiEatMode && selectedEdibleIndices.includes(idx)
                                ? 'border-green-500 border-4 ring-2 ring-green-400'
                                : shellBowlMode && selectedShellIndices.includes(idx)
                                ? 'border-amber-500 border-4 ring-2 ring-amber-400'
                                : gameState.pendingAction?.selectedCardIndex === idx 
                                ? 'border-blue-500 border-4 ring-2 ring-blue-400' 
                                : selectedCaffeineIndex === idx
                                ? 'border-yellow-500 border-4 ring-2 ring-yellow-400'
                                : 'border-yellow-700'
                            }`}
                            disabled={!isMyTurn}
                          >
                            <img 
                              src={CARD_IMAGES[card.type] || 'images/cards/cardBack.PNG'}
                              alt={card.type}
                              className="w-full h-full object-cover"
                              onError={(e) => {
                                e.target.style.display = 'none';
                                e.target.nextSibling.style.display = 'flex';
                              }}
                            />
                            <div 
                              className="absolute inset-0 bg-gradient-to-br from-yellow-400 to-yellow-600 flex items-center justify-center"
                              style={{display: 'none'}}
                            >
                              <div className="text-center px-1">
                                <div className="font-black text-xs text-yellow-900 break-words">
                                  {card.type.toUpperCase()}
                                </div>
                              </div>
                            </div>
                          </button>
                        );
                      })}
                    </div>
                  </>
                  )}

                  {gameState.goldenPistachioEvent && 
                   gameState.goldenPistachioEvent.playersNeedingResponse.includes(playerId) &&
                   !gameState.goldenPistachioEvent.responses?.[playerId] && (
                    <div className="bg-yellow-50 border-2 border-yellow-400 rounded-xl p-4 mb-4 mt-4">
                      <div className="text-center mb-3">
                        <h4 className="text-lg font-bold text-yellow-900">‚ú® GOLDEN PISTACHIO! ‚ú®</h4>
                        <p className="text-sm text-yellow-700 mt-1">
                          {gameState.players[gameState.goldenPistachioEvent.playedBy]?.name} played a Golden Pistachio!
                          <br />You must eat food OR lose 1 energy token.
                        </p>
                      </div>
                      <div className="flex gap-2">
                        <button 
                          onClick={async () => {
                            const newTokens = Math.max(0, myPlayer.energyTokens - 1);
                            const updates = {};
                            updates[`players/${playerId}/energyTokens`] = newTokens;
                            updates[`goldenPistachioEvent/responses/${playerId}`] = 'paid';
                            
                            if (newTokens === 0) {
                              updates[`players/${playerId}/eliminated`] = true;
                            }
                            
                            const responses = {...(gameState.goldenPistachioEvent.responses || {}), [playerId]: 'paid'};
                            const allResponded = gameState.goldenPistachioEvent.playersNeedingResponse.every(pid => responses[pid]);
                            if (allResponded) {
                              updates['goldenPistachioEvent'] = null;
                            }
                            
                            await database.ref(`games/${roomCode}`).update(updates);
                          }}
                          disabled={myPlayer.energyTokens <= 0}
                          className="flex-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                        >
                          üíÄ Lose 1 Token
                        </button>
                        <button 
                          onClick={() => {
                            setError('Click an edible card above to eat it!');
                          }}
                          disabled={!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type))}
                          className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 rounded-xl transition-colors"
                        >
                          üçΩÔ∏è Eat Food
                        </button>
                      </div>
                      <p className="text-xs text-center text-yellow-600 mt-2">
                        {!myPlayer.hand?.some(c => ['pistachio', 'pesky', 'loose', 'golden', 'raisin'].includes(c.type)) 
                          ? "No edible food in hand - must lose token" 
                          : "Click edible cards above to eat"}
                      </p>
                    </div>
                  )}

                  {isMyTurn && (
                    <div className="mt-4 space-y-3">
                      {/* Raccoon Card - Steal from opponent */}
                      {gameState.pendingAction && gameState.pendingAction.type === 'raccoon' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-gray-50 border-2 border-gray-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-gray-900">ü¶ù RACCOON! ü¶ù</h4>
                            <p className="text-sm text-gray-700 mt-1">
                              Select an opponent to steal {gameState.pendingAction.isCaffeinated ? '2 random cards' : '1 random card'} from!
                            </p>
                          </div>
                          <div className="grid grid-cols-2 gap-2">
                            {Object.values(gameState.players)
                              .filter(p => p.id !== playerId && p.connected && !p.eliminated && p.hand?.length > 0)
                              .map((player) => (
                                <button
                                  key={player.id}
                                  onClick={async () => {
                                    const cardsToSteal = Math.min(
                                      gameState.pendingAction.isCaffeinated ? 2 : 1,
                                      player.hand.length
                                    );
                                    
                                    const victimHand = [...player.hand];
                                    const stolenCards = [];
                                    
                                    for (let i = 0; i < cardsToSteal; i++) {
                                      const randomIndex = Math.floor(Math.random() * victimHand.length);
                                      stolenCards.push(victimHand.splice(randomIndex, 1)[0]);
                                    }
                                    
                                    const myNewHand = [...myPlayer.hand, ...stolenCards];
                                    const players = Object.values(gameState.players).filter(p => p.connected && !p.eliminated);
                                    
                                    await database.ref(`games/${roomCode}`).update({
                                      [`players/${playerId}/hand`]: myNewHand,
                                      [`players/${player.id}/hand`]: victimHand,
                                      pendingAction: null
                                    });
                                    
                                    setError(`Stole ${cardsToSteal} card(s) from ${player.name}!`);
                                  }}
                                  className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg"
                                >
                                  <div className="flex items-center gap-2 justify-center">
                                    <div 
                                      className="w-4 h-4 rounded-full" 
                                      style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                                    />
                                    <span>{player.name}</span>
                                  </div>
                                  <div className="text-xs mt-1">{player.hand.length} cards</div>
                                </button>
                              ))}
                          </div>
                          {Object.values(gameState.players).filter(p => p.id !== playerId && p.connected && !p.eliminated && p.hand?.length > 0).length === 0 && (
                            <div className="text-center">
                              <p className="text-sm text-gray-600 mb-3">No opponents with cards to steal from!</p>
                              <button
                                onClick={async () => {
                                  await database.ref(`games/${roomCode}/pendingAction`).set(null);
                                }}
                                className="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg"
                              >
                                Continue
                              </button>
                            </div>
                          )}
                        </div>
                      )}

                      {/* Donate Card - Give to opponent */}
                      {gameState.pendingAction && gameState.pendingAction.type === 'donate' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-blue-50 border-2 border-blue-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-blue-900">üéÅ DONATE! üéÅ</h4>
                            <p className="text-sm text-blue-700 mt-1">
                              {gameState.pendingAction.selectedCardIndex === undefined 
                                ? `Select ${gameState.pendingAction.cardsToGive} card(s) from your hand to donate`
                                : 'Now select which opponent receives the card(s)'}
                            </p>
                          </div>
                          
                          {gameState.pendingAction.selectedCardIndex === undefined ? (
                            <p className="text-xs text-center text-blue-600">Click a card above to select it</p>
                          ) : (
                            <div className="grid grid-cols-2 gap-2">
                              {Object.values(gameState.players)
                                .filter(p => p.id !== playerId && p.connected && !p.eliminated)
                                .map((player) => (
                                  <button
                                    key={player.id}
                                    onClick={async () => {
                                      const cardIndex = gameState.pendingAction.selectedCardIndex;
                                      const cardToDonate = myPlayer.hand[cardIndex];
                                      const newMyHand = myPlayer.hand.filter((_, i) => i !== cardIndex);
                                      const newOpponentHand = [...player.hand, cardToDonate];
                                      
                                      await database.ref(`games/${roomCode}`).update({
                                        [`players/${playerId}/hand`]: newMyHand,
                                        [`players/${player.id}/hand`]: newOpponentHand,
                                        pendingAction: null
                                      });
                                      
                                      setError(`Donated ${cardToDonate.type} to ${player.name}!`);
                                    }}
                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg"
                                  >
                                    <div className="flex items-center gap-2 justify-center">
                                      <div 
                                        className="w-4 h-4 rounded-full" 
                                        style={{ backgroundColor: PLAYER_COLORS[player.colorIndex] }}
                                      />
                                      <span>{player.name}</span>
                                    </div>
                                  </button>
                                ))}
                            </div>
                          )}
                        </div>
                      )}

                      {/* Picky Card - Reorder top cards */}
                      {gameState.pendingAction && gameState.pendingAction.type === 'picky' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-purple-50 border-2 border-purple-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-purple-900">üîç PICKY! üîç</h4>
                            <p className="text-sm text-purple-700 mt-1">
                              Rearrange the top {gameState.pendingAction.topCards.length} cards of the deck
                            </p>
                          </div>
                          
                          <div>
                            <div className="space-y-2 mb-4">
                              {pickyReorderedCards.map((card, idx) => (
                                <div key={idx} className="flex items-center gap-2 bg-white p-3 rounded-lg border-2 border-purple-300">
                                  <div className="flex-1">
                                    <div className="font-bold text-purple-900">
                                      {idx === 0 ? 'üîù Top' : idx === pickyReorderedCards.length - 1 ? '‚¨áÔ∏è Bottom' : `üìÑ Position ${idx + 1}`}
                                    </div>
                                    <div className="text-sm text-purple-700">{card.type}</div>
                                  </div>
                                  <div className="flex gap-1">
                                    <button
                                      onClick={() => {
                                        if (idx > 0) {
                                          const newOrder = [...pickyReorderedCards];
                                          [newOrder[idx], newOrder[idx - 1]] = [newOrder[idx - 1], newOrder[idx]];
                                          setPickyReorderedCards(newOrder);
                                        }
                                      }}
                                      disabled={idx === 0}
                                      className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 text-white px-3 py-1 rounded disabled:cursor-not-allowed"
                                    >
                                      ‚¨ÜÔ∏è
                                    </button>
                                    <button
                                      onClick={() => {
                                        if (idx < pickyReorderedCards.length - 1) {
                                          const newOrder = [...pickyReorderedCards];
                                          [newOrder[idx], newOrder[idx + 1]] = [newOrder[idx + 1], newOrder[idx]];
                                          setPickyReorderedCards(newOrder);
                                        }
                                      }}
                                      disabled={idx === pickyReorderedCards.length - 1}
                                      className="bg-purple-500 hover:bg-purple-600 disabled:bg-gray-300 text-white px-3 py-1 rounded disabled:cursor-not-allowed"
                                    >
                                      ‚¨áÔ∏è
                                    </button>
                                  </div>
                                </div>
                              ))}
                            </div>
                            
                            <button
                              onClick={async () => {
                                const newDeck = [...gameState.deck];
                                newDeck.splice(0, gameState.pendingAction.topCards.length, ...pickyReorderedCards);
                                
                                await database.ref(`games/${roomCode}`).update({
                                  deck: newDeck,
                                  pendingAction: null
                                });
                                
                                setPickyReorderedCards([]);
                                setError('Cards reordered on top of deck!');
                              }}
                              className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded-xl transition-colors"
                            >
                              ‚úì Confirm Order
                            </button>
                          </div>
                        </div>
                      )}

                      {/* Moldy Pistachio */}
                      {gameState.pendingAction && gameState.pendingAction.type === 'moldy' && gameState.pendingAction.playerId === playerId && (
                        <div className="bg-green-50 border-2 border-green-600 rounded-xl p-4">
                          <div className="text-center mb-3">
                            <h4 className="text-lg font-bold text-green-900">ü¶† MOLDY PISTACHIO! ü¶†</h4>
                            <p className="text
